var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _events, _accounts, _origin, _name, _signTransactionBlock, _signPersonalMessage, _on, _setAccount, setAccount_fn, _connect, _disconnect;
import { bcs } from "@mysten/sui.js/bcs";
import { toB64 } from "@mysten/sui.js/utils";
import { getWallets, ReadonlyWalletAccount, SUI_MAINNET_CHAIN } from "@mysten/wallet-standard";
import mitt from "mitt";
import { DEFAULT_STASHED_ORIGIN, StashedPopup } from "./channel/index.js";
const STASHED_RECENT_ADDRESS_KEY = "stashed:recentAddress";
const STASHED_WALLET_NAME = "Stashed";
class StashedWallet {
  constructor({
    name,
    address,
    origin = DEFAULT_STASHED_ORIGIN
  }) {
    __privateAdd(this, _setAccount);
    __privateAdd(this, _events, void 0);
    __privateAdd(this, _accounts, void 0);
    __privateAdd(this, _origin, void 0);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _signTransactionBlock, async ({ transactionBlock, account }) => {
      transactionBlock.setSenderIfNotSet(account.address);
      const data = transactionBlock.serialize();
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "sign-transaction-block",
        data,
        address: account.address
      });
      return {
        transactionBlockBytes: response.bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _signPersonalMessage, async ({ message, account }) => {
      const bytes = toB64(bcs.vector(bcs.u8()).serialize(message).toBytes());
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "sign-personal-message",
        bytes,
        address: account.address
      });
      return {
        bytes,
        signature: response.signature
      };
    });
    __privateAdd(this, _on, (event, listener) => {
      __privateGet(this, _events).on(event, listener);
      return () => __privateGet(this, _events).off(event, listener);
    });
    __privateAdd(this, _connect, async (input) => {
      if (input?.silent) {
        const address = localStorage.getItem(STASHED_RECENT_ADDRESS_KEY);
        if (address) {
          __privateMethod(this, _setAccount, setAccount_fn).call(this, address);
        }
        return { accounts: this.accounts };
      }
      const popup = new StashedPopup({ name: __privateGet(this, _name), origin: __privateGet(this, _origin) });
      const response = await popup.createRequest({
        type: "connect"
      });
      if (!("address" in response)) {
        throw new Error("Unexpected response");
      }
      __privateMethod(this, _setAccount, setAccount_fn).call(this, response.address);
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      localStorage.removeItem(STASHED_RECENT_ADDRESS_KEY);
      __privateMethod(this, _setAccount, setAccount_fn).call(this);
    });
    __privateSet(this, _accounts, []);
    __privateSet(this, _events, mitt());
    __privateSet(this, _origin, origin);
    __privateSet(this, _name, name);
    if (address) {
      __privateMethod(this, _setAccount, setAccount_fn).call(this, address);
    }
  }
  get name() {
    return STASHED_WALLET_NAME;
  }
  get icon() {
    return "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMzIgMzIiIHdpZHRoPSIzMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGNsaXBQYXRoIGlkPSJhIj48cmVjdCBoZWlnaHQ9IjMyIiByeD0iMiIgd2lkdGg9IjMyIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjYSkiPjxyZWN0IGZpbGw9IiNmZmYiIGhlaWdodD0iMzIiIHJ4PSIyIiB3aWR0aD0iMzIiLz48cGF0aCBkPSJtMCAwaDMydjMyaC0zMnoiIGZpbGw9IiNkNDA1NTEiLz48cGF0aCBkPSJtNS42NjgyNSAyNS4yNDkxYy0uNzgyNjMtLjc4MjctLjc4MDgxLTIuMDUyMS4wMDQwNi0yLjgzMjVsMTYuNjA1MjktMTYuNTEwNDdjLjc4MTctLjc3NzIzIDIuMDQ0OS0uNzc1NDMgMi44MjQzLjAwNDA0bC44Mzg3LjgzODYyYy43ODI1Ljc4MjUxLjc4MDggMi4wNTE3NC0uMDAzOCAyLjgzMjE4bC0xNi42MDE4OCAxNi41MTM4M2MtLjc4MTY1Ljc3NzUtMi4wNDUwOC43NzU4LTIuODI0NjYtLjAwMzd6bTUuNDQzMzUtMTUuOTExNjZjLTEuODA5NzIuMDUzNjctMi43NTM3MS0yLjEzMzA5LTEuNDczNDctMy40MTMzM2wuODM4MzctLjgzODMyYy4zNzUtLjM3NTA4Ljg4MzctLjU4NTc5IDEuNDE0Mi0uNTg1NzloMTMuNDc5N2MxLjEwNDYgMCAyIC44OTU0MyAyIDJ2MTMuNDc5N2MwIC41MzA1LS4yMTA3IDEuMDM5Mi0uNTg1OCAxLjQxNDJsLS44MjY5LjgyN2MtMS4yODE4IDEuMjgxOC0zLjQ3MDkuMzMzOS0zLjQxMzItMS40Nzc5bC4zMDY2LTkuNjI5OWMuMDM2Ny0xLjE1MjI3LS45MDU5LTIuMDk2OS0yLjA1ODMtMi4wNjI3M3oiIGZpbGw9IiNmZmYiLz48L2c+PC9zdmc+";
  }
  get version() {
    return "1.0.0";
  }
  get chains() {
    return [SUI_MAINNET_CHAIN];
  }
  get accounts() {
    return __privateGet(this, _accounts);
  }
  get features() {
    return {
      "standard:connect": {
        version: "1.0.0",
        connect: __privateGet(this, _connect)
      },
      "standard:disconnect": {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect)
      },
      "standard:events": {
        version: "1.0.0",
        on: __privateGet(this, _on)
      },
      "sui:signTransactionBlock": {
        version: "1.0.0",
        signTransactionBlock: __privateGet(this, _signTransactionBlock)
      },
      "sui:signPersonalMessage": {
        version: "1.0.0",
        signPersonalMessage: __privateGet(this, _signPersonalMessage)
      }
    };
  }
}
_events = new WeakMap();
_accounts = new WeakMap();
_origin = new WeakMap();
_name = new WeakMap();
_signTransactionBlock = new WeakMap();
_signPersonalMessage = new WeakMap();
_on = new WeakMap();
_setAccount = new WeakSet();
setAccount_fn = function(address) {
  if (address) {
    __privateSet(this, _accounts, [
      new ReadonlyWalletAccount({
        address,
        chains: [SUI_MAINNET_CHAIN],
        features: ["sui:signTransactionBlock", "sui:signPersonalMessage"],
        // NOTE: Stashed doesn't support getting public keys, and zkLogin accounts don't have meaningful public keys anyway
        publicKey: new Uint8Array()
      })
    ]);
    localStorage.setItem(STASHED_RECENT_ADDRESS_KEY, address);
  } else {
    __privateSet(this, _accounts, []);
  }
  __privateGet(this, _events).emit("change", { accounts: this.accounts });
};
_connect = new WeakMap();
_disconnect = new WeakMap();
function registerStashedWallet(name, {
  origin
}) {
  const wallets = getWallets();
  let addressFromRedirect = null;
  try {
    const params = new URLSearchParams(window.location.search);
    addressFromRedirect = params.get("stashed_address") || params.get("zksend_address");
  } catch {
  }
  const wallet = new StashedWallet({
    name,
    origin,
    address: addressFromRedirect
  });
  const unregister = wallets.register(wallet);
  return {
    wallet,
    unregister,
    addressFromRedirect
  };
}
export {
  STASHED_WALLET_NAME,
  StashedWallet,
  registerStashedWallet
};
//# sourceMappingURL=index.js.map
