{
  "version": 3,
  "sources": ["../../.pnpm/base-x@4.0.1/node_modules/base-x/src/index.js", "../../.pnpm/bs58@5.0.0/node_modules/bs58/index.js", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/b58.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/b64.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/hex.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/uleb.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/reader.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/utils.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/writer.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/bcs-type.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/bcs.ts", "../../.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/src/legacy-registry.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/utils/sui-types.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/error.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/utils.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/struct.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/structs/utilities.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/structs/types.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/structs/coercions.ts", "../../.pnpm/superstruct@1.0.4/node_modules/superstruct/src/structs/refinements.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/utils/index.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/utils.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/serializer.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/bcs/type-tag-serializer.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/bcs/index.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/Inputs.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/Transactions.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/pure.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/hash.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/TransactionBlockData.ts", "../../.pnpm/@mysten+sui.js@0.54.1_typescript@5.8.3/node_modules/@mysten/sui.js/src/transactions/TransactionBlock.ts"],
  "sourcesContent": ["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n", "const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromB64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toB64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tsize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\n\t\tthis.size = size;\n\t\tthis.maxSize = maxSize || size;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58.js';\nimport { toB64 } from './b64.js';\nimport { toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif ('Some' in value) {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: true };\n\t\t\t\t}[keyof T],\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t\t}[keyof T]\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? { [K2 in K]: U } : { [K2 in K]: true };\n\t\t\t}[keyof T],\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t}[keyof T]\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value)[0];\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(`Expected object with one key, found ${keys.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst [name] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, name)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${name}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * @deprecated\n\t *\n\t * Generics should be implemented as generic typescript functions instead:\n\t *\n\t * ```ts\n\t * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n\t *   return bcs.struct('VecMap<K, V>', {\n\t *     keys: bcs.vector(K),\n\t *     values: bcs.vector(V),\n\t *   })\n\t * }\n\t * ```\n\t */\n\tgeneric<const Names extends readonly string[], const Type extends BcsType<any>>(\n\t\t_names: Names,\n\t\tcb: (...types: { [K in keyof Names]: BcsType<GenericPlaceholder<Names[K]>> }) => Type,\n\t): <T extends { [K in keyof Names]: BcsType<any> }>(\n\t\t...types: T\n\t) => ReplaceBcsGenerics<Type, Names, T> {\n\t\treturn (...types) => {\n\t\t\treturn cb(...types).transform({\n\t\t\t\tname: `${cb.name}<${types.map((t) => t.name).join(', ')}>`,\n\t\t\t\tinput: (value) => value,\n\t\t\t\toutput: (value) => value,\n\t\t\t}) as never;\n\t\t};\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { BcsType } from './bcs-type.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport type { Encoding } from './types.js';\nimport { decodeStr, splitGenericParameters } from './utils.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Predefined types constants\n\tstatic readonly U8 = 'u8';\n\tstatic readonly U16 = 'u16';\n\tstatic readonly U32 = 'u32';\n\tstatic readonly U64 = 'u64';\n\tstatic readonly U128 = 'u128';\n\tstatic readonly U256 = 'u256';\n\tstatic readonly BOOL = 'bool';\n\tstatic readonly VECTOR = 'vector';\n\tstatic readonly ADDRESS = 'address';\n\tstatic readonly STRING = 'string';\n\tstatic readonly HEX = 'hex-string';\n\tstatic readonly BASE58 = 'base58-string';\n\tstatic readonly BASE64 = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register BcsType instances to the registry\n\t * Types are registered with a callback that provides BcsType instances for each generic\n\t * passed to the type.\n\t *\n\t * - createType(...generics) - Return a BcsType instance\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('Box<T>', (T) => {\n\t * \t\treturn bcs.struct({\n\t * \t\t\tvalue: T\n\t * \t\t});\n\t * });\n\n\t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param createType a Callback to create the BcsType with any passed in generics\n\t */\n\tpublic registerBcsType(\n\t\ttypeName: TypeName,\n\t\tcreateType: (...params: BcsType<any>[]) => BcsType<any>,\n\t) {\n\t\tthis.registerType(\n\t\t\ttypeName,\n\t\t\t(writer, data, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._encodeRaw.call(this, writer, data, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: () => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tcreateType(...generics).write(data, writer);\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\t(reader, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (_data, _writer) => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: (reader) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn createType(...generics).read(reader);\n\t\t\t},\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@mysten/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n\ttry {\n\t\tconst buffer = fromB58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is string {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t  )\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams?.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): string {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): string {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n", null, null, null, null, null, null, null, "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { formatAddress, formatDigest } from './format.js';\nimport {\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tparseStructTag,\n\tSUI_ADDRESS_LENGTH,\n} from './sui-types.js';\n\nexport { fromB64, toB64, fromHEX, toHEX } from '@mysten/bcs';\nexport { is, assert } from 'superstruct';\n\nexport {\n\tformatAddress,\n\tformatDigest,\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tparseStructTag,\n\tSUI_ADDRESS_LENGTH,\n};\n\nexport { isValidSuiNSName, normalizeSuiNSName } from './suins.js';\n\nexport const SUI_DECIMALS = 9;\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Struct } from 'superstruct';\nimport { create as superstructCreate } from 'superstruct';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\n\nexport function create<T, S>(value: T, struct: Struct<T, S>): T {\n\treturn superstructCreate(value, struct);\n}\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiJsonValue, SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { isValidSuiAddress } from '../utils/sui-types.js';\nimport { extractStructTag } from './utils.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nconst RESOLVED_SUI_ID = {\n\taddress: SUI_FRAMEWORK_ADDRESS,\n\tmodule: OBJECT_MODULE_NAME,\n\tname: ID_STRUCT_NAME,\n};\nconst RESOLVED_ASCII_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_ASCII_MODULE_NAME,\n\tname: STD_ASCII_STRUCT_NAME,\n};\nconst RESOLVED_UTF8_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_UTF8_MODULE_NAME,\n\tname: STD_UTF8_STRUCT_NAME,\n};\n\nconst RESOLVED_STD_OPTION = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_OPTION_MODULE_NAME,\n\tname: STD_OPTION_STRUCT_NAME,\n};\n\nconst isSameStruct = (a: any, b: any) =>\n\ta.address === b.address && a.module === b.module && a.name === b.name;\n\nexport function isTxContext(param: SuiMoveNormalizedType): boolean {\n\tconst struct = extractStructTag(param)?.Struct;\n\treturn (\n\t\tstruct?.address === '0x2' && struct?.module === 'tx_context' && struct?.name === 'TxContext'\n\t);\n}\n\nfunction expectType(typeName: string, argVal?: SuiJsonValue) {\n\tif (typeof argVal === 'undefined') {\n\t\treturn;\n\t}\n\tif (typeof argVal !== typeName) {\n\t\tthrow new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n\t}\n}\n\nconst allowedTypes = ['Address', 'Bool', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256'];\n\nexport function getPureSerializationType(\n\tnormalizedType: SuiMoveNormalizedType,\n\targVal: SuiJsonValue | undefined,\n): string | undefined {\n\tif (typeof normalizedType === 'string' && allowedTypes.includes(normalizedType)) {\n\t\tif (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {\n\t\t\texpectType('number', argVal);\n\t\t} else if (normalizedType === 'Bool') {\n\t\t\texpectType('boolean', argVal);\n\t\t} else if (normalizedType === 'Address') {\n\t\t\texpectType('string', argVal);\n\t\t\tif (argVal && !isValidSuiAddress(argVal as string)) {\n\t\t\t\tthrow new Error('Invalid Sui Address');\n\t\t\t}\n\t\t}\n\t\treturn normalizedType.toLowerCase();\n\t} else if (typeof normalizedType === 'string') {\n\t\tthrow new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n\t}\n\n\tif ('Vector' in normalizedType) {\n\t\tif ((argVal === undefined || typeof argVal === 'string') && normalizedType.Vector === 'U8') {\n\t\t\treturn 'string';\n\t\t}\n\n\t\tif (argVal !== undefined && !Array.isArray(argVal)) {\n\t\t\tthrow new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n\t\t}\n\n\t\tconst innerType = getPureSerializationType(\n\t\t\tnormalizedType.Vector,\n\t\t\t// undefined when argVal is empty\n\t\t\targVal ? argVal[0] : undefined,\n\t\t);\n\n\t\tif (innerType === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn `vector<${innerType}>`;\n\t}\n\n\tif ('Struct' in normalizedType) {\n\t\tif (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n\t\t\treturn 'string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n\t\t\treturn 'utf8string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n\t\t\treturn 'address';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n\t\t\tconst optionToVec: SuiMoveNormalizedType = {\n\t\t\t\tVector: normalizedType.Struct.typeArguments[0],\n\t\t\t};\n\t\t\treturn getPureSerializationType(optionToVec, argVal);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './index.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromB64,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoB64,\n\ttoHEX,\n} from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../transactions/Transactions.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\nexport type SuiObjectRef = {\n\t/** Base64 string representing the object digest */\n\tobjectId: string;\n\t/** Object version */\n\tversion: number | string | bigint;\n\t/** Hex code as string representing the object id */\n\tdigest: string;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRef }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRef };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRef[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nconst IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nconst IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nconst AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nconst Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nconst IntentMessage = bcs.generic(['T'], (T) =>\n\tbcs.struct('IntentMessage<T>', {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t}),\n);\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\toutput: (val) => toB64(new Uint8Array(val)),\n});\n\nconst SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport { array, bigint, boolean, integer, number, object, string, union } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SharedObjectRef } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n\nexport const SuiObjectRef = object({\n\t/** Base64 string representing the object digest */\n\tdigest: string(),\n\t/** Hex code as string representing the object id */\n\tobjectId: string(),\n\t/** Object version */\n\tversion: union([number(), string(), bigint()]),\n});\nexport type SuiObjectRef = Infer<typeof SuiObjectRef>;\n\nconst ObjectArg = union([\n\tobject({ ImmOrOwned: SuiObjectRef }),\n\tobject({\n\t\tShared: object({\n\t\t\tobjectId: string(),\n\t\t\tinitialSharedVersion: union([integer(), string()]),\n\t\t\tmutable: boolean(),\n\t\t}),\n\t}),\n\tobject({ Receiving: SuiObjectRef }),\n]);\n\nexport const PureCallArg = object({ Pure: array(integer()) });\nexport const ObjectCallArg = object({ Object: ObjectArg });\nexport type PureCallArg = Infer<typeof PureCallArg>;\nexport type ObjectCallArg = Infer<typeof ObjectCallArg>;\n\nexport const BuilderCallArg = union([PureCallArg, ObjectCallArg]);\nexport type BuilderCallArg = Infer<typeof BuilderCallArg>;\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>, type?: string): PureCallArg;\n/** @deprecated pass SerializedBcs values instead */\nfunction Pure(data: unknown, type?: string): PureCallArg;\nfunction Pure(data: unknown, type?: string): PureCallArg {\n\treturn {\n\t\tPure: Array.from(\n\t\t\tdata instanceof Uint8Array\n\t\t\t\t? data\n\t\t\t\t: isSerializedBcs(data)\n\t\t\t\t? data.toBytes()\n\t\t\t\t: // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:\n\t\t\t\t  bcs.ser(type!, data, { maxSize: Infinity }).toBytes(),\n\t\t),\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tImmOrOwned: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({ objectId, mutable, initialSharedVersion }: SharedObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tShared: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n\nexport function getIdFromCallArg(arg: string | ObjectCallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\tif ('ImmOrOwned' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);\n\t}\n\n\tif ('Receiving' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t}\n\n\treturn normalizeSuiAddress(arg.Object.Shared.objectId);\n}\n\nexport function getSharedObjectInput(arg: BuilderCallArg): SharedObjectRef | undefined {\n\treturn typeof arg === 'object' && 'Object' in arg && 'Shared' in arg.Object\n\t\t? arg.Object.Shared\n\t\t: undefined;\n}\n\nexport function isSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn !!getSharedObjectInput(arg);\n}\n\nexport function isMutableSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn getSharedObjectInput(arg)?.mutable ?? false;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n\tany,\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tobject,\n\toptional,\n\trecord,\n\tstring,\n\tunion,\n\tunknown,\n} from 'superstruct';\n\nimport type { TypeTag } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport { TypeTagSerializer } from '../bcs/type-tag-serializer.js';\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Inputs } from './Inputs.js';\nimport { create } from './utils.js';\n\nconst option = <T extends Struct<any, any>>(some: T) =>\n\tunion([object({ None: union([literal(true), literal(null)]) }), object({ Some: some })]);\n\nexport const TransactionBlockInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: literal('pure'),\n\t}),\n]);\nexport type TransactionBlockInput = Infer<typeof TransactionBlockInput>;\n\nconst TransactionArgumentTypes = [\n\tTransactionBlockInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: integer() }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: integer(),\n\t\tresultIndex: integer(),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\nexport type TransactionArgument = Infer<typeof TransactionArgument>;\n\nexport const MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: define<`${string}::${string}::${string}`>('target', string().validator),\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\nexport type MoveCallTransaction = Infer<typeof MoveCallTransaction>;\n\nexport const TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\nexport type TransferObjectsTransaction = Infer<typeof TransferObjectsTransaction>;\n\nexport const SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\nexport type SplitCoinsTransaction = Infer<typeof SplitCoinsTransaction>;\n\nexport const MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\nexport type MergeCoinsTransaction = Infer<typeof MergeCoinsTransaction>;\n\nexport const MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\t// TODO: ideally we should use `TypeTag` instead of `record()` here,\n\t// but TypeTag is recursively defined and it's tricky to define a\n\t// recursive struct in superstruct\n\ttype: optional(option(record(string(), unknown()))) as never as Struct<\n\t\t{ Some: TypeTag } | { None: true | null }\n\t>,\n\tobjects: array(TransactionArgument),\n});\nexport type MakeMoveVecTransaction = Infer<typeof MakeMoveVecTransaction>;\n\nexport const PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n});\nexport type PublishTransaction = Infer<typeof PublishTransaction>;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\nexport const UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\nexport type UpgradeTransaction = Infer<typeof UpgradeTransaction>;\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nexport const TransactionType = union([...TransactionTypes]);\nexport type TransactionType = Infer<typeof TransactionType>;\n\nexport function getTransactionType(data: unknown) {\n\tassert(data, TransactionType);\n\treturn TransactionTypes.find((schema) => is(data, schema as Struct))!;\n}\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Transactions = {\n\tMoveCall(\n\t\tinput: Omit<MoveCallTransaction, 'kind' | 'arguments' | 'typeArguments'> & {\n\t\t\targuments?: TransactionArgument[];\n\t\t\ttypeArguments?: string[];\n\t\t},\n\t): MoveCallTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MoveCall',\n\t\t\t\ttarget: input.target,\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t},\n\t\t\tMoveCallTransaction,\n\t\t);\n\t},\n\tTransferObjects(\n\t\tobjects: TransactionArgument[],\n\t\taddress: TransactionArgument,\n\t): TransferObjectsTransaction {\n\t\tif (address.kind === 'Input' && address.type === 'pure' && typeof address.value !== 'object') {\n\t\t\taddress.value = Inputs.Pure(bcs.Address.serialize(address.value));\n\t\t}\n\n\t\treturn create({ kind: 'TransferObjects', objects, address }, TransferObjectsTransaction);\n\t},\n\tSplitCoins(coin: TransactionArgument, amounts: TransactionArgument[]): SplitCoinsTransaction {\n\t\t// Handle deprecated usage of `Input.Pure(100)`\n\t\tamounts.forEach((input) => {\n\t\t\tif (input.kind === 'Input' && input.type === 'pure' && typeof input.value !== 'object') {\n\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t}\n\t\t});\n\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'SplitCoins',\n\t\t\t\tcoin,\n\t\t\t\tamounts,\n\t\t\t},\n\t\t\tSplitCoinsTransaction,\n\t\t);\n\t},\n\tMergeCoins(\n\t\tdestination: TransactionArgument,\n\t\tsources: TransactionArgument[],\n\t): MergeCoinsTransaction {\n\t\treturn create({ kind: 'MergeCoins', destination, sources }, MergeCoinsTransaction);\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): PublishTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Publish',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t\tPublishTransaction,\n\t\t);\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionArgument;\n\t}): UpgradeTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Upgrade',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackageId,\n\t\t\t\tticket,\n\t\t\t},\n\t\t\tUpgradeTransaction,\n\t\t);\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: Omit<MakeMoveVecTransaction, 'kind' | 'type'> & {\n\t\ttype?: string;\n\t}): MakeMoveVecTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\ttype: type ? { Some: TypeTagSerializer.parseFromStr(type) } : { None: null },\n\t\t\t\tobjects,\n\t\t\t},\n\t\t\tMakeMoveVecTransaction,\n\t\t);\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { TransactionBlockInput } from './Transactions.js';\n\nexport function createPure(\n\tmakePure: (value: unknown, type?: string | undefined) => TransactionBlockInput,\n) {\n\t/**\n\t * Add a new non-object input to the transaction.\n\t */\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): TransactionBlockInput;\n\t/**\n\t * @deprecated Pass the pure value as SerializedBcs instead.\n\t */\n\tfunction pure(\n\t\t/**\n\t\t * The pure value that will be used as the input value. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: unknown,\n\t\t/**\n\t\t * The BCS type to serialize the value into. If not provided, the type will automatically be determined\n\t\t * based on how the input is used.\n\t\t */\n\t\ttype?: string,\n\t): TransactionBlockInput;\n\n\tfunction pure(value: unknown, type?: string): TransactionBlockInput {\n\t\treturn makePure(value, type);\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport {\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tnullable,\n\tobject,\n\toptional,\n\tstring,\n\tunion,\n} from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { hashTypedData } from './hash.js';\nimport { BuilderCallArg, PureCallArg, SuiObjectRef } from './Inputs.js';\nimport { TransactionBlockInput, TransactionType } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport const TransactionExpiration = optional(\n\tnullable(\n\t\tunion([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })]),\n\t),\n);\nexport type TransactionExpiration = Infer<typeof TransactionExpiration>;\n\nconst StringEncodedBigint = define<string | number | bigint>('StringEncodedBigint', (val) => {\n\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\ttry {\n\t\tBigInt(val as string);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(SuiObjectRef)),\n\towner: optional(string()),\n});\ntype GasConfig = Infer<typeof GasConfig>;\n\nexport const SerializedTransactionDataBuilder = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: TransactionExpiration,\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionBlockInput),\n\ttransactions: array(TransactionType),\n});\nexport type SerializedTransactionDataBuilder = Infer<typeof SerializedTransactionDataBuilder>;\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionBlockDataBuilder {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\t\tconst programmableTx = 'ProgrammableTransaction' in kind ? kind.ProgrammableTransaction : null;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tgasConfig: {},\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx =\n\t\t\t'ProgrammableTransaction' in data.kind ? data?.kind?.ProgrammableTransaction : null;\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tsender: data.sender,\n\t\t\t\texpiration: data.expiration,\n\t\t\t\tgasConfig: data.gasData,\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic restore(data: SerializedTransactionDataBuilder) {\n\t\tassert(data, SerializedTransactionDataBuilder);\n\t\tconst transactionData = new TransactionBlockDataBuilder();\n\t\tObject.assign(transactionData, data);\n\t\treturn transactionData;\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toB58(hash);\n\t}\n\n\tversion = 1 as const;\n\tsender?: string;\n\texpiration?: TransactionExpiration;\n\tgasConfig: GasConfig;\n\tinputs: TransactionBlockInput[];\n\ttransactions: TransactionType[];\n\n\tconstructor(clone?: SerializedTransactionDataBuilder) {\n\t\tthis.sender = clone?.sender;\n\t\tthis.expiration = clone?.expiration;\n\t\tthis.gasConfig = clone?.gasConfig ?? {};\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.transactions = clone?.transactions ?? [];\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: Pick<Partial<TransactionBlockDataBuilder>, 'sender' | 'gasConfig' | 'expiration'>;\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// Resolve inputs down to values:\n\t\tconst inputs = this.inputs.map((input) => {\n\t\t\tassert(input.value, BuilderCallArg);\n\t\t\treturn input.value;\n\t\t});\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\ttransactions: this.transactions,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasConfig = { ...this.gasConfig, ...overrides?.gasConfig };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasConfig.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasConfig.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasConfig.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasConfig.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n\t\t\t\tprice: BigInt(gasConfig.price),\n\t\t\t\tbudget: BigInt(gasConfig.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\ttransactions: this.transactions,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): SerializedTransactionDataBuilder {\n\t\treturn create(this, SerializedTransactionDataBuilder);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tObjectCallArg,\n\tPureCallArg,\n\tSuiObjectRef,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create, extractMutableReference, extractReference, extractStructTag } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Signer;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\n\t\t// Upgrade shared object inputs to mutable if needed:\n\t\tif (\n\t\t\tinserted &&\n\t\t\tis(inserted.value, ObjectCallArg) &&\n\t\t\t'Shared' in inserted.value.Object &&\n\t\t\tis(value, ObjectCallArg) &&\n\t\t\t'Shared' in value.Object\n\t\t) {\n\t\t\tinserted.value.Object.Shared.mutable =\n\t\t\t\tinserted.value.Object.Shared.mutable || value.Object.Shared.mutable;\n\t\t}\n\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(object.data!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(object.data!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AAMA,aAAS,KAAM,UAAU;AACvB,UAAI,SAAS,UAAU,KAAK;AAAE,cAAM,IAAI,UAAU,mBAAmB;AAAA,MAAE;AACvE,UAAI,WAAW,IAAI,WAAW,GAAG;AACjC,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,iBAAS,CAAC,IAAI;AAAA,MAChB;AACA,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAI,IAAI,SAAS,OAAO,CAAC;AACzB,YAAI,KAAK,EAAE,WAAW,CAAC;AACvB,YAAI,SAAS,EAAE,MAAM,KAAK;AAAE,gBAAM,IAAI,UAAU,IAAI,eAAe;AAAA,QAAE;AACrE,iBAAS,EAAE,IAAI;AAAA,MACjB;AACA,UAAI,OAAO,SAAS;AACpB,UAAI,SAAS,SAAS,OAAO,CAAC;AAC9B,UAAI,SAAS,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG;AAC1C,UAAI,UAAU,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,IAAI;AAC3C,eAAS,OAAQ,QAAQ;AACvB,YAAI,kBAAkB,YAAY;AAAA,QAClC,WAAW,YAAY,OAAO,MAAM,GAAG;AACrC,mBAAS,IAAI,WAAW,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAAA,QAC7E,WAAW,MAAM,QAAQ,MAAM,GAAG;AAChC,mBAAS,WAAW,KAAK,MAAM;AAAA,QACjC;AACA,YAAI,EAAE,kBAAkB,aAAa;AAAE,gBAAM,IAAI,UAAU,qBAAqB;AAAA,QAAE;AAClF,YAAI,OAAO,WAAW,GAAG;AAAE,iBAAO;AAAA,QAAG;AAErC,YAAI,SAAS;AACb,YAAI,SAAS;AACb,YAAI,SAAS;AACb,YAAI,OAAO,OAAO;AAClB,eAAO,WAAW,QAAQ,OAAO,MAAM,MAAM,GAAG;AAC9C;AACA;AAAA,QACF;AAEA,YAAI,QAAS,OAAO,UAAU,UAAU,MAAO;AAC/C,YAAI,MAAM,IAAI,WAAW,IAAI;AAE7B,eAAO,WAAW,MAAM;AACtB,cAAI,QAAQ,OAAO,MAAM;AAEzB,cAAIA,KAAI;AACR,mBAAS,MAAM,OAAO,IAAI,UAAU,KAAKA,KAAI,WAAY,QAAQ,IAAK,OAAOA,MAAK;AAChF,qBAAU,MAAM,IAAI,GAAG,MAAO;AAC9B,gBAAI,GAAG,IAAK,QAAQ,SAAU;AAC9B,oBAAS,QAAQ,SAAU;AAAA,UAC7B;AACA,cAAI,UAAU,GAAG;AAAE,kBAAM,IAAI,MAAM,gBAAgB;AAAA,UAAE;AACrD,mBAASA;AACT;AAAA,QACF;AAEA,YAAI,MAAM,OAAO;AACjB,eAAO,QAAQ,QAAQ,IAAI,GAAG,MAAM,GAAG;AACrC;AAAA,QACF;AAEA,YAAI,MAAM,OAAO,OAAO,MAAM;AAC9B,eAAO,MAAM,MAAM,EAAE,KAAK;AAAE,iBAAO,SAAS,OAAO,IAAI,GAAG,CAAC;AAAA,QAAE;AAC7D,eAAO;AAAA,MACT;AACA,eAAS,aAAc,QAAQ;AAC7B,YAAI,OAAO,WAAW,UAAU;AAAE,gBAAM,IAAI,UAAU,iBAAiB;AAAA,QAAE;AACzE,YAAI,OAAO,WAAW,GAAG;AAAE,iBAAO,IAAI,WAAW;AAAA,QAAE;AACnD,YAAI,MAAM;AAEV,YAAI,SAAS;AACb,YAAI,SAAS;AACb,eAAO,OAAO,GAAG,MAAM,QAAQ;AAC7B;AACA;AAAA,QACF;AAEA,YAAI,QAAU,OAAO,SAAS,OAAO,SAAU,MAAO;AACtD,YAAI,OAAO,IAAI,WAAW,IAAI;AAE9B,eAAO,OAAO,GAAG,GAAG;AAElB,cAAI,WAAW,OAAO,WAAW,GAAG;AAEpC,cAAI,WAAW,KAAK;AAAE;AAAA,UAAO;AAE7B,cAAI,QAAQ,SAAS,QAAQ;AAE7B,cAAI,UAAU,KAAK;AAAE;AAAA,UAAO;AAC5B,cAAIA,KAAI;AACR,mBAAS,MAAM,OAAO,IAAI,UAAU,KAAKA,KAAI,WAAY,QAAQ,IAAK,OAAOA,MAAK;AAChF,qBAAU,OAAO,KAAK,GAAG,MAAO;AAChC,iBAAK,GAAG,IAAK,QAAQ,QAAS;AAC9B,oBAAS,QAAQ,QAAS;AAAA,UAC5B;AACA,cAAI,UAAU,GAAG;AAAE,kBAAM,IAAI,MAAM,gBAAgB;AAAA,UAAE;AACrD,mBAASA;AACT;AAAA,QACF;AAEA,YAAI,MAAM,OAAO;AACjB,eAAO,QAAQ,QAAQ,KAAK,GAAG,MAAM,GAAG;AACtC;AAAA,QACF;AACA,YAAI,MAAM,IAAI,WAAW,UAAU,OAAO,IAAI;AAC9C,YAAIC,KAAI;AACR,eAAO,QAAQ,MAAM;AACnB,cAAIA,IAAG,IAAI,KAAK,KAAK;AAAA,QACvB;AACA,eAAO;AAAA,MACT;AACA,eAAS,OAAQC,SAAQ;AACvB,YAAI,SAAS,aAAaA,OAAM;AAChC,YAAI,QAAQ;AAAE,iBAAO;AAAA,QAAO;AAC5B,cAAM,IAAI,MAAM,aAAa,OAAO,YAAY;AAAA,MAClD;AACA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,UAAU;AAAA;AAAA;;;AC5HjB;AAAA;AAAA,QAAM,QAAQ;AACd,QAAM,WAAW;AAEjB,WAAO,UAAU,MAAM,QAAQ;AAAA;AAAA;;;ACA/B,kBAAiB;AAEV,IAAM,QAAQ,CAAC,WAAuB,YAAAC,QAAK,OAAO,MAAM;AACxD,IAAM,UAAU,CAAC,QAAgB,YAAAA,QAAK,OAAO,GAAG;;;ACHhD,SAAS,QAAQC,eAAkC;AACzD,SAAO,WAAW,KAAK,KAAKA,aAAY,GAAG,CAAC,SAAS,KAAK,WAAW,CAAC,CAAC;AACxE;AAEA,IAAM,aAAa;AACZ,SAAS,MAAM,OAA2B;AAEhD,MAAI,MAAM,SAAS,YAAY;AAC9B,WAAO,KAAK,OAAO,aAAa,GAAG,KAAK,CAAC;EAC1C;AAEA,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,YAAY;AAClD,UAAMC,SAAQ,MAAM,MAAM,GAAG,IAAI,UAAU;AAC3C,cAAU,OAAO,aAAa,GAAGA,MAAK;EACvC;AAEA,SAAO,KAAK,MAAM;AACnB;;;AClBO,SAAS,QAAQ,QAA4B;AAA7C;AACN,QAAM,aAAa,OAAO,WAAW,IAAI,IAAI,OAAO,MAAM,CAAC,IAAI;AAC/D,QAAM,SAAS,WAAW,SAAS,MAAM,IAAI,aAAa,IAAI,UAAA;AAC9D,QAAM,WAAS,YAAO,MAAM,OAAO,MAApB,mBAAuB,IAAI,CAAC,SAAS,SAAS,MAAM,EAAE,OAAM,CAAC;AAE5E,SAAO,WAAW,KAAK,MAAM;AAC9B;AAEO,SAAS,MAAM,OAA2B;AAChD,SAAO,MAAM,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE;AAChF;;;ACRO,SAAS,WAAW,KAAuB;AACjD,MAAI,MAAM,CAAC;AACX,MAAI,MAAM;AAEV,MAAI,QAAQ,GAAG;AACd,WAAO,CAAC,CAAC;EACV;AAEA,SAAO,MAAM,GAAG;AACf,QAAI,GAAG,IAAI,MAAM;AACjB,QAAK,QAAQ,GAAI;AAChB,UAAI,GAAG,KAAK;IACb;AACA,WAAO;EACR;AAEA,SAAO;AACR;AAIO,SAAS,WAAW,KAGzB;AACD,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,MAAM;AAGV,SAAO,MAAM;AACZ,QAAI,OAAO,IAAI,GAAG;AAClB,WAAO;AACP,cAAU,OAAO,QAAS;AAC1B,SAAK,OAAO,SAAU,GAAG;AACxB;IACD;AACA,aAAS;EACV;AAEA,SAAO;IACN,OAAO;IACP,QAAQ;EACT;AACD;;;ACdO,IAAM,YAAN,MAAgB;;;;EAOtB,YAAY,MAAkB;AAL9B,SAAQ,eAAuB;AAM9B,SAAK,WAAW,IAAI,SAAS,KAAK,MAAM;EACzC;;;;;;;EAOA,MAAM,OAAe;AACpB,SAAK,gBAAgB;AACrB,WAAO;EACR;;;;;EAKA,QAAgB;AACf,QAAI,QAAQ,KAAK,SAAS,SAAS,KAAK,YAAY;AACpD,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,QAAI,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC3D,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,QAAI,QAAQ,KAAK,SAAS,UAAU,KAAK,cAAc,IAAI;AAC3D,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;;EAKA,SAAiB;AAChB,QAAI,SAAS,KAAK,OAAO;AACzB,QAAI,SAAS,KAAK,OAAO;AAEzB,QAAI,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG;AAEtE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;EAIA,UAAkB;AACjB,QAAI,SAAS,OAAO,KAAK,OAAO,CAAC;AACjC,QAAI,SAAS,OAAO,KAAK,OAAO,CAAC;AACjC,QAAI,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEvE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;;EAKA,UAAkB;AACjB,QAAI,SAAS,OAAO,KAAK,QAAQ,CAAC;AAClC,QAAI,SAAS,OAAO,KAAK,QAAQ,CAAC;AAClC,QAAI,SAAS,OAAO,SAAS,EAAE,IAAI,OAAO,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAEvE,WAAO,OAAO,OAAO,MAAM,EAAE,SAAS,EAAE;EACzC;;;;;EAKA,UAAU,KAAyB;AAClC,QAAI,QAAQ,KAAK,eAAe,KAAK,SAAS;AAC9C,QAAI,QAAQ,IAAI,WAAW,KAAK,SAAS,QAAQ,OAAO,GAAG;AAE3D,SAAK,MAAM,GAAG;AAEd,WAAO;EACR;;;;;;EAMA,WAAmB;AAClB,QAAI,QAAQ,KAAK,eAAe,KAAK,SAAS;AAC9C,QAAI,SAAS,IAAI,WAAW,KAAK,SAAS,QAAQ,KAAK;AACvD,QAAI,EAAE,OAAO,OAAO,IAAI,WAAW,MAAM;AAEzC,SAAK,MAAM,MAAM;AAEjB,WAAO;EACR;;;;;;;EAOA,QAAQ,IAAkE;AACzE,QAAI,SAAS,KAAK,SAAS;AAC3B,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,aAAO,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;IAChC;AACA,WAAO;EACR;AACD;;;AC5IO,SAAS,UAAU,MAAkB,UAA4B;AACvE,UAAQ,UAAU;IACjB,KAAK;AACJ,aAAO,MAAM,IAAI;IAClB,KAAK;AACJ,aAAO,MAAM,IAAI;IAClB,KAAK;AACJ,aAAO,MAAM,IAAI;IAClB;AACC,YAAM,IAAI,MAAM,yDAAyD;EAC3E;AACD;AASO,SAAS,UAAU,MAAc,UAAgC;AACvE,UAAQ,UAAU;IACjB,KAAK;AACJ,aAAO,QAAQ,IAAI;IACpB,KAAK;AACJ,aAAO,QAAQ,IAAI;IACpB,KAAK;AACJ,aAAO,QAAQ,IAAI;IACpB;AACC,YAAM,IAAI,MAAM,yDAAyD;EAC3E;AACD;AAEO,SAAS,uBACf,KACA,oBAAsC,CAAC,KAAK,GAAG,GAC9C;AACD,QAAM,CAAC,MAAM,KAAK,IAAI;AACtB,QAAM,MAAM,CAAC;AACb,MAAI,OAAO;AACX,MAAI,sBAAsB;AAE1B,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,UAAM,OAAO,IAAI,CAAC;AAClB,QAAI,SAAS,MAAM;AAClB;IACD;AACA,QAAI,SAAS,OAAO;AACnB;IACD;AACA,QAAI,wBAAwB,KAAK,SAAS,KAAK;AAC9C,UAAI,KAAK,KAAK,KAAK,CAAC;AACpB,aAAO;AACP;IACD;AACA,YAAQ;EACT;AAEA,MAAI,KAAK,KAAK,KAAK,CAAC;AAEpB,SAAO;AACR;;;AC1CO,IAAM,YAAN,MAAgB;EAOtB,YAAY,EAAE,OAAO,MAAM,SAAS,eAAe,KAAK,IAAsB,CAAC,GAAG;AALlF,SAAQ,eAAuB;AAM9B,SAAK,OAAO;AACZ,SAAK,UAAU,WAAW;AAC1B,SAAK,eAAe;AACpB,SAAK,WAAW,IAAI,SAAS,IAAI,YAAY,IAAI,CAAC;EACnD;EAEQ,iBAAiB,OAAe;AACvC,UAAM,eAAe,KAAK,eAAe;AACzC,QAAI,eAAe,KAAK,MAAM;AAC7B,YAAM,WAAW,KAAK,IAAI,KAAK,SAAS,KAAK,OAAO,KAAK,YAAY;AACrE,UAAI,eAAe,UAAU;AAC5B,cAAM,IAAI;UACT,yFAAyF,KAAK,IAAA,eAAmB,KAAK,OAAA,oBAA2B,YAAA;QAClJ;MACD;AAEA,WAAK,OAAO;AACZ,YAAM,aAAa,IAAI,YAAY,KAAK,IAAI;AAC5C,UAAI,WAAW,UAAU,EAAE,IAAI,IAAI,WAAW,KAAK,SAAS,MAAM,CAAC;AACnE,WAAK,WAAW,IAAI,SAAS,UAAU;IACxC;EACD;;;;;;;EAQA,MAAM,OAAqB;AAC1B,SAAK,gBAAgB;AACrB,WAAO;EACR;;;;;;EAMA,OAAO,OAA8B;AACpC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,SAAS,KAAK,cAAc,OAAO,KAAK,CAAC;AACvD,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAMA,QAAQ,OAA8B;AACrC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,UAAU,KAAK,cAAc,OAAO,KAAK,GAAG,IAAI;AAC9D,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAMA,QAAQ,OAA8B;AACrC,SAAK,iBAAiB,CAAC;AACvB,SAAK,SAAS,UAAU,KAAK,cAAc,OAAO,KAAK,GAAG,IAAI;AAC9D,WAAO,KAAK,MAAM,CAAC;EACpB;;;;;;EAMA,QAAQ,OAA8B;AACrC,mBAAe,OAAO,KAAK,GAAG,CAAC,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEhE,WAAO;EACR;;;;;;;EAOA,SAAS,OAA8B;AACtC,mBAAe,OAAO,KAAK,GAAG,EAAE,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEjE,WAAO;EACR;;;;;;;EAOA,SAAS,OAA8B;AACtC,mBAAe,OAAO,KAAK,GAAG,EAAE,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AAEjE,WAAO;EACR;;;;;;;EAOA,UAAU,OAAqB;AAC9B,eAAW,KAAK,EAAE,QAAQ,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;AACjD,WAAO;EACR;;;;;;;;;EASA,SAAS,QAAe,IAAwE;AAC/F,SAAK,UAAU,OAAO,MAAM;AAC5B,UAAM,KAAK,MAAM,EAAE,QAAQ,CAAC,IAAI,MAAM,GAAG,MAAM,IAAI,GAAG,OAAO,MAAM,CAAC;AACpE,WAAO;EACR;;;;;EAMA,EAAE,OAAO,QAAQ,IAAwC;AACxD,aAAS,IAAI,GAAG,IAAI,KAAK,cAAc,KAAK;AAC3C,YAAM,KAAK,SAAS,SAAS,CAAC;IAC/B;AACA,WAAO,KAAK,QAAQ;EACrB;;;;;EAMA,UAAsB;AACrB,WAAO,IAAI,WAAW,KAAK,SAAS,OAAO,MAAM,GAAG,KAAK,YAAY,CAAC;EACvE;;;;;EAMA,SAAS,UAA4B;AACpC,WAAO,UAAU,KAAK,QAAQ,GAAG,QAAQ;EAC1C;AACD;AAEA,SAAS,eAAeC,SAAgB,MAAc;AACrD,MAAI,SAAS,IAAI,WAAW,IAAI;AAChC,MAAI,IAAI;AACR,SAAOA,UAAS,GAAG;AAClB,WAAO,CAAC,IAAI,OAAOA,UAAS,OAAO,GAAG,CAAC;AACvC,IAAAA,UAASA,UAAS,OAAO,GAAG;AAC5B,SAAK;EACN;AACA,SAAO;AACR;;;;;;;;;;;;;;;;;;;;;ACtMA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAgBO,IAAM,WAAN,MAA4B;EAUlC,YACC,SAQC;AAZF,iBAAA,MAAA,QAAA,MAAA;AACA,iBAAA,MAAA,YAAA,MAAA;AAYC,SAAK,OAAO,QAAQ;AACpB,SAAK,OAAO,QAAQ;AACpB,SAAK,iBAAiB,QAAQ,mBAAmB,MAAM;AACvD,iBAAA,MAAK,QAAS,QAAQ,KAAA;AACtB,iBAAA,MAAK,YACJ,QAAQ,cACP,CAAC,OAAOC,aAAY;AACpB,YAAM,SAAS,IAAI,UAAU,EAAE,MAAM,KAAK,eAAe,KAAK,KAAK,QAAW,GAAGA,SAAQ,CAAC;AAC1F,mBAAA,MAAK,MAAA,EAAL,KAAA,MAAY,OAAO,MAAA;AACnB,aAAO,OAAO,QAAQ;IACvB,EAAA;AAED,SAAK,WAAW,QAAQ,aAAa,MAAM;IAAC;EAC7C;EAEA,MAAM,OAAc,QAAmB;AACtC,SAAK,SAAS,KAAK;AACnB,iBAAA,MAAK,MAAA,EAAL,KAAA,MAAY,OAAO,MAAA;EACpB;EAEA,UAAU,OAAc,SAA4B;AACnD,SAAK,SAAS,KAAK;AACnB,WAAO,IAAI,cAAc,MAAM,aAAA,MAAK,UAAA,EAAL,KAAA,MAAgB,OAAO,OAAA,CAAQ;EAC/D;EAEA,MAAM,OAAsB;AAC3B,UAAM,SAAS,IAAI,UAAU,KAAK;AAClC,WAAO,KAAK,KAAK,MAAM;EACxB;EAEA,UAAsB;IACrB;IACA;IACA;EACD,GAGgC;AAC/B,WAAO,IAAI,SAAoB;MAC9B,MAAM,QAAQ,KAAK;MACnB,MAAM,CAAC,WAAW,OAAO,KAAK,KAAK,MAAM,CAAC;MAC1C,OAAO,CAAC,OAAO,WAAW,aAAA,MAAK,MAAA,EAAL,KAAA,MAAY,MAAM,KAAK,GAAG,MAAA;MACpD,gBAAgB,CAAC,UAAU,KAAK,eAAe,MAAM,KAAK,CAAC;MAC3D,WAAW,CAAC,OAAO,YAAY,aAAA,MAAK,UAAA,EAAL,KAAA,MAAgB,MAAM,KAAK,GAAG,OAAA;MAC7D,UAAU,CAAC,UAAU,KAAK,SAAS,MAAM,KAAK,CAAC;IAChD,CAAC;EACF;AACD;AAnEO,IAAM,UAAN;AAON,SAAA,oBAAA,QAAA;AACA,aAAA,oBAAA,QAAA;AA6DD,IAAM,uBAAuB,OAAO,IAAI,wBAAwB;AACzD,SAAS,gBAAgB,KAA6C;AAC5E,SAAO,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAa,IAAY,oBAAoB,MAAM;AACnF;AAEO,IAAM,gBAAN,MAAkC;EAUxC,YAAY,MAAyB,QAAoB;AATzD,iBAAA,MAAA,SAAA,MAAA;AACA,iBAAA,MAAA,QAAA,MAAA;AASC,iBAAA,MAAK,SAAU,IAAA;AACf,iBAAA,MAAK,QAAS,MAAA;EACf;;;EAPA,KAAK,oBAAoB,IAAI;AAC5B,WAAO;EACR;EAOA,UAAU;AACT,WAAO,aAAA,MAAK,MAAA;EACb;EAEA,QAAQ;AACP,WAAO,MAAM,aAAA,MAAK,MAAA,CAAM;EACzB;EAEA,WAAW;AACV,WAAO,MAAM,aAAA,MAAK,MAAA,CAAM;EACzB;EAEA,WAAW;AACV,WAAO,MAAM,aAAA,MAAK,MAAA,CAAM;EACzB;EAEA,QAAQ;AACP,WAAO,aAAA,MAAK,OAAA,EAAQ,MAAM,aAAA,MAAK,MAAA,CAAM;EACtC;AACD;AAjCC,UAAA,oBAAA,QAAA;AACA,SAAA,oBAAA,QAAA;AAkCM,SAAS,iBAA+B;EAC9C;EACA,GAAG;AACJ,GAK8B;AAC7B,SAAO,IAAI,QAAkB;IAC5B,GAAG;IACH,gBAAgB,MAAM;EACvB,CAAC;AACF;AAEO,SAAS,YAAY;EAC3B;EACA;EACA,GAAG;AACJ,GAMoC;AACnC,SAAO,iBAAyB;IAC/B,GAAG;IACH,MAAM,CAAC,WAAW,OAAO,UAAU,EAAE;IACrC,OAAO,CAAC,OAAO,WAAW,OAAO,WAAW,EAAE,KAAK;IACnD,UAAU,CAAC,UAAU;;AACpB,UAAI,QAAQ,KAAK,QAAQ,QAAQ,UAAU;AAC1C,cAAM,IAAI;UACT,WAAW,QAAQ,IAAA,WAAe,KAAA,+BAAoC,QAAQ,QAAA;QAC/E;MACD;AACA,oBAAQ,aAAR,iCAAmB;IACpB;EACD,CAAC;AACF;AAEO,SAAS,eAAe;EAC9B;EACA;EACA,GAAG;AACJ,GAMsD;AACrD,SAAO,iBAAmD;IACzD,GAAG;IACH,MAAM,CAAC,WAAW,OAAO,UAAU,EAAE;IACrC,OAAO,CAAC,OAAO,WAAW,OAAO,WAAW,EAAE,OAAO,KAAK,CAAC;IAC3D,UAAU,CAAC,QAAQ;;AAClB,YAAM,QAAQ,OAAO,GAAG;AACxB,UAAI,QAAQ,KAAK,QAAQ,QAAQ,UAAU;AAC1C,cAAM,IAAI;UACT,WAAW,QAAQ,IAAA,WAAe,KAAA,+BAAoC,QAAQ,QAAA;QAC/E;MACD;AACA,oBAAQ,aAAR,iCAAmB;IACpB;EACD,CAAC;AACF;AAEO,SAAS,mBAAiC;EAChD;EACA,GAAG;AACJ,GAI8B;AAC7B,QAAM,OAAO,IAAI,QAAkB;IAClC,GAAG;IACH;IACA,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAW,QAAQ,KAAK,UAAU,KAAK,EAAE,QAAQ,GAAG;AACnD,eAAO,OAAO,IAAI;MACnB;IACD;EACD,CAAC;AAED,SAAO;AACR;AAEO,SAAS,kBAAkB;EACjC;EACA;EACA,GAAG;AACJ,GAK4B;AAC3B,SAAO,IAAI,QAAgB;IAC1B,GAAG;IACH,MAAM,CAAC,WAAW;AACjB,YAAM,SAAS,OAAO,SAAS;AAC/B,YAAM,QAAQ,OAAO,UAAU,MAAM;AAErC,aAAO,UAAU,KAAK;IACvB;IACA,OAAO,CAAC,KAAK,WAAW;AACvB,YAAM,QAAQ,QAAQ,GAAG;AACzB,aAAO,UAAU,MAAM,MAAM;AAC7B,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,eAAO,OAAO,MAAM,CAAC,CAAC;MACvB;IACD;IACA,WAAW,CAAC,UAAU;AACrB,YAAM,QAAQ,QAAQ,KAAK;AAC3B,YAAM,OAAO,WAAW,MAAM,MAAM;AACpC,YAAM,SAAS,IAAI,WAAW,KAAK,SAAS,MAAM,MAAM;AACxD,aAAO,IAAI,MAAM,CAAC;AAClB,aAAO,IAAI,OAAO,KAAK,MAAM;AAE7B,aAAO;IACR;IACA,UAAU,CAAC,UAAU;;AACpB,UAAI,OAAO,UAAU,UAAU;AAC9B,cAAM,IAAI,UAAU,WAAW,QAAQ,IAAA,WAAe,KAAA,mBAAwB;MAC/E;AACA,oBAAQ,aAAR,iCAAmB;IACpB;EACD,CAAC;AACF;AAEO,SAAS,YAAsB,IAA6B;AAClE,MAAI,WAAqC;AACzC,WAAS,UAAU;AAClB,QAAI,CAAC,UAAU;AACd,iBAAW,GAAG;IACf;AACA,WAAO;EACR;AAEA,SAAO,IAAI,QAAkB;IAC5B,MAAM;IACN,MAAM,CAAC,SAAS,QAAQ,EAAE,KAAK,IAAI;IACnC,gBAAgB,CAAC,UAAU,QAAQ,EAAE,eAAe,KAAK;IACzD,OAAO,CAAC,OAAO,WAAW,QAAQ,EAAE,MAAM,OAAO,MAAM;IACvD,WAAW,CAAC,OAAO,YAAY,QAAQ,EAAE,UAAU,OAAO,OAAO,EAAE,QAAQ;EAC5E,CAAC;AACF;;;AClQO,IAAM,MAAM;;;;;;EAMlB,GAAG,SAAkC;AACpC,WAAO,YAAY;MAClB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,IAAI;MACnB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,IAAI,SAAkC;AACrC,WAAO,YAAY;MAClB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,KAAK;MACpB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,IAAI,SAAkC;AACrC,WAAO,YAAY;MAClB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,KAAK,KAAK;MACpB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,IAAI,SAA4D;AAC/D,WAAO,eAAe;MACrB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,MAAM;MACtB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,KAAK,SAA4D;AAChE,WAAO,eAAe;MACrB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,OAAO;MACvB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,KAAK,SAA4D;AAChE,WAAO,eAAe;MACrB,MAAM;MACN,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU,MAAM,OAAO;MACvB,GAAG;IACJ,CAAC;EACF;;;;;;EAOA,KAAK,SAAmC;AACvC,WAAO,iBAA0B;MAChC,MAAM;MACN,MAAM;MACN,MAAM,CAAC,WAAW,OAAO,MAAM,MAAM;MACrC,OAAO,CAAC,OAAO,WAAW,OAAO,OAAO,QAAQ,IAAI,CAAC;MACrD,GAAG;MACH,UAAU,CAAC,UAAU;AAzHxB;AA0HI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,OAAO,UAAU,WAAW;AAC/B,gBAAM,IAAI,UAAU,2BAA2B,OAAO,KAAA,EAAO;QAC9D;MACD;IACD,CAAC;EACF;;;;;;EAOA,QAAQ,SAAkC;AACzC,WAAO,mBAA2B;MACjC,MAAM;MACN,MAAM,CAAC,WAAW,OAAO,SAAS;MAClC,WAAW,CAAC,UAAU;AACrB,eAAO,WAAW,KAAK,WAAW,KAAK,CAAC;MACzC;MACA,GAAG;IACJ,CAAC;EACF;;;;;;;EAQA,MAAwB,MAAS,SAAwD;AACxF,WAAO,iBAA6B;MACnC,MAAM,SAAS,IAAA;MACf;MACA,MAAM,CAAC,WAAW,OAAO,UAAU,IAAI;MACvC,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,iBAAO,OAAO,MAAM,CAAC,KAAK,CAAC;QAC5B;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AAnKxB;AAoKI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,EAAE,YAAY,QAAQ;AACzB,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAA,EAAO;QAC5D;AACA,YAAI,MAAM,WAAW,MAAM;AAC1B,gBAAM,IAAI,UAAU,4BAA4B,IAAA,WAAe,MAAM,MAAA,EAAQ;QAC9E;MACD;IACD,CAAC;EACF;;;;;;EAOA,OAAO,SAAkC;AACxC,WAAO,kBAAkB;MACxB,MAAM;MACN,SAAS,CAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK;MAClD,WAAW,CAAC,UAAU,IAAI,YAAY,EAAE,OAAO,KAAK;MACpD,GAAG;IACJ,CAAC;EACF;;;;;;;;EASA,WACC,MACA,MACA,SACC;AACD,WAAO,IAAI,QAAmD;MAC7D,MAAM,GAAG,KAAK,IAAA,IAAQ,IAAA;MACtB,MAAM,CAAC,WAAW;AACjB,cAAM,SAAc,IAAI,MAAM,IAAI;AAClC,iBAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAC9B,iBAAO,CAAC,IAAI,KAAK,KAAK,MAAM;QAC7B;AACA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,mBAAW,QAAQ,OAAO;AACzB,eAAK,MAAM,MAAM,MAAM;QACxB;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AAxNxB;AAyNI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,EAAE,YAAY,QAAQ;AACzB,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAA,EAAO;QAC5D;AACA,YAAI,MAAM,WAAW,MAAM;AAC1B,gBAAM,IAAI,UAAU,4BAA4B,IAAA,WAAe,MAAM,MAAA,EAAQ;QAC9E;MACD;IACD,CAAC;EACF;;;;;;;;EASA,OAAiB,MAAyB;AACzC,WAAO,IACL,KAAK,UAAU,KAAK,IAAA,KAAS;MAC7B,MAAM;MACN,MAAM;IACP,CAAC,EACA,UAAU;MACV,OAAO,CAAC,UAAoC;AAC3C,YAAI,SAAS,MAAM;AAClB,iBAAO,EAAE,MAAM,KAAK;QACrB;AAEA,eAAO,EAAE,MAAM,MAAM;MACtB;MACA,QAAQ,CAAC,UAAU;AAClB,YAAI,UAAU,OAAO;AACpB,iBAAO,MAAM;QACd;AAEA,eAAO;MACR;IACD,CAAC;EACH;;;;;;;;EASA,OACC,MACA,SACC;AACD,WAAO,IAAI,QAAmD;MAC7D,MAAM,UAAU,KAAK,IAAA;MACrB,MAAM,CAAC,WAAW;AACjB,cAAM,SAAS,OAAO,SAAS;AAC/B,cAAM,SAAc,IAAI,MAAM,MAAM;AACpC,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,iBAAO,CAAC,IAAI,KAAK,KAAK,MAAM;QAC7B;AACA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,eAAO,UAAU,MAAM,MAAM;AAC7B,mBAAW,QAAQ,OAAO;AACzB,eAAK,MAAM,MAAM,MAAM;QACxB;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AA/RxB;AAgSI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,EAAE,YAAY,QAAQ;AACzB,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAA,EAAO;QAC5D;MACD;IACD,CAAC;EACF;;;;;;;;;EAUA,MACC,OACA,SAQC;AACD,WAAO,IAAI,QAOT;MACD,MAAM,IAAI,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,IAAI,CAAA;MAC5C,gBAAgB,CAAC,WAAW;AAC3B,YAAI,QAAQ;AACZ,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,gBAAM,OAAO,MAAM,CAAC,EAAE,eAAe,OAAO,CAAC,CAAC;AAC9C,cAAI,QAAQ,MAAM;AACjB,mBAAO;UACR;AAEA,mBAAS;QACV;AAEA,eAAO;MACR;MACA,MAAM,CAAC,WAAW;AACjB,cAAM,SAAoB,CAAC;AAC3B,mBAAW,QAAQ,OAAO;AACzB,iBAAO,KAAK,KAAK,KAAK,MAAM,CAAC;QAC9B;AACA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,gBAAM,CAAC,EAAE,MAAM,MAAM,CAAC,GAAG,MAAM;QAChC;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AA9VxB;AA+VI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,gBAAM,IAAI,UAAU,yBAAyB,OAAO,KAAA,EAAO;QAC5D;AACA,YAAI,MAAM,WAAW,MAAM,QAAQ;AAClC,gBAAM,IAAI,UAAU,4BAA4B,MAAM,MAAA,WAAiB,MAAM,MAAA,EAAQ;QACtF;MACD;IACD,CAAC;EACF;;;;;;;;;;;;;EAcA,OACC,MACA,QACA,SAWC;AACD,UAAM,iBAAiB,OAAO,QAAQ,MAAM;AAE5C,WAAO,IAAI,QAOT;MACD;MACA,gBAAgB,CAAC,WAAW;AAC3B,YAAI,QAAQ;AACZ,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,gBAAM,OAAO,KAAK,eAAe,OAAO,KAAK,CAAC;AAC9C,cAAI,QAAQ,MAAM;AACjB,mBAAO;UACR;AAEA,mBAAS;QACV;AAEA,eAAO;MACR;MACA,MAAM,CAAC,WAAW;AACjB,cAAM,SAAkC,CAAC;AACzC,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,iBAAO,KAAK,IAAI,KAAK,KAAK,MAAM;QACjC;AAEA,eAAO;MACR;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,mBAAW,CAAC,OAAO,IAAI,KAAK,gBAAgB;AAC3C,eAAK,MAAM,MAAM,KAAK,GAAG,MAAM;QAChC;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AA3axB;AA4aI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,OAAO,UAAU,YAAY,SAAS,MAAM;AAC/C,gBAAM,IAAI,UAAU,0BAA0B,OAAO,KAAA,EAAO;QAC7D;MACD;IACD,CAAC;EACF;;;;;;;;;;;;;;;;;EAkBA,KACC,MACA,QACA,SAeC;AACD,UAAM,iBAAiB,OAAO,QAAQ,MAAgB;AACtD,WAAO,IAAI,QAST;MACD;MACA,MAAM,CAAC,WAAW;AACjB,cAAM,QAAQ,OAAO,SAAS;AAC9B,cAAM,CAACC,OAAM,IAAI,IAAI,eAAe,KAAK;AACzC,eAAO;UACN,CAACA,KAAI,IAAG,6BAAM,KAAK,YAAW;QAC/B;MACD;MACA,OAAO,CAAC,OAAO,WAAW;AACzB,cAAM,CAACA,OAAM,GAAG,IAAI,OAAO,QAAQ,KAAK,EAAE,CAAC;AAC3C,iBAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC/C,gBAAM,CAAC,YAAY,UAAU,IAAI,eAAe,CAAC;AACjD,cAAI,eAAeA,OAAM;AACxB,mBAAO,UAAU,CAAC;AAClB,qDAAY,MAAM,KAAK;AACvB;UACD;QACD;MACD;MACA,GAAG;MACH,UAAU,CAAC,UAAU;AAtfxB;AAufI,iDAAS,aAAT,iCAAoB;AACpB,YAAI,OAAO,UAAU,YAAY,SAAS,MAAM;AAC/C,gBAAM,IAAI,UAAU,0BAA0B,OAAO,KAAA,EAAO;QAC7D;AAEA,cAAM,OAAO,OAAO,KAAK,KAAK;AAC9B,YAAI,KAAK,WAAW,GAAG;AACtB,gBAAM,IAAI,UAAU,uCAAuC,KAAK,MAAA,EAAQ;QACzE;AAEA,cAAM,CAACA,KAAI,IAAI;AAEf,YAAI,CAAC,OAAO,OAAO,QAAQA,KAAI,GAAG;AACjC,gBAAM,IAAI,UAAU,wBAAwBA,KAAAA,EAAM;QACnD;MACD;IACD,CAAC;EACF;;;;;;;;;EAUA,IAAkC,SAA6B,WAA+B;AAC7F,WAAO,IAAI,OAAO,IAAI,MAAM,CAAC,SAAS,SAAS,CAAC,CAAC,EAAE,UAAU;MAC5D,MAAM,OAAO,QAAQ,IAAA,KAAS,UAAU,IAAA;MACxC,OAAO,CAAC,UAA+B;AACtC,eAAO,CAAC,GAAG,MAAM,QAAQ,CAAC;MAC3B;MACA,QAAQ,CAAC,UAAU;AAClB,cAAM,SAAS,oBAAI,IAAU;AAC7B,mBAAW,CAAC,KAAK,GAAG,KAAK,OAAO;AAC/B,iBAAO,IAAI,KAAK,GAAG;QACpB;AACA,eAAO;MACR;IACD,CAAC;EACF;;;;;;;;;;;;;;;EAgBA,QACC,QACA,IAGuC;AACvC,WAAO,IAAI,UAAU;AACpB,aAAO,GAAG,GAAG,KAAK,EAAE,UAAU;QAC7B,MAAM,GAAG,GAAG,IAAA,IAAQ,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,IAAI,CAAA;QACtD,OAAO,CAAC,UAAU;QAClB,QAAQ,CAAC,UAAU;MACpB,CAAC;IACF;EACD;;;;;EAMA,KAA6B,IAAgB;AAC5C,WAAO,YAAY,EAAE;EACtB;AACD;;;ACljBA,IAAM,qBAAqB;AA8FpB,IAAM,OAAN,MAAU;;;;;;;EAiDhB,YAAY,QAAyB;AA3BrC,SAAO,QAA6C,oBAAI,IAAI;AAU5D,SAAU,UAAkB;AAmB3B,QAAI,kBAAkB,MAAK;AAC1B,WAAK,SAAS,OAAO;AACrB,WAAK,QAAQ,IAAI,IAAI,OAAO,KAAK;AACjC;IACD;AAEA,SAAK,SAAS;AAGd,SAAK,oBAAoB,KAAI,SAAS,OAAO,eAAe,OAAO,eAAe;AAClF,SAAK,mBAAmB,OAAO,UAAU;AAGzC,QAAI,OAAO,SAAS,OAAO,MAAM,SAAS;AACzC,eAAS,QAAQ,OAAO,KAAK,OAAO,MAAM,OAAO,GAAG;AACnD,aAAK,mBAAmB,MAAM,OAAO,MAAM,QAAQ,IAAI,CAAC;MACzD;IACD;AAGA,QAAI,OAAO,SAAS,OAAO,MAAM,OAAO;AACvC,eAAS,QAAQ,OAAO,KAAK,OAAO,MAAM,KAAK,GAAG;AACjD,aAAK,iBAAiB,MAAM,OAAO,MAAM,MAAM,IAAI,CAAC;MACrD;IACD;AAGA,QAAI,OAAO,SAAS,OAAO,MAAM,SAAS;AACzC,eAAS,QAAQ,OAAO,KAAK,OAAO,MAAM,OAAO,GAAG;AACnD,aAAK,cAAc,MAAM,OAAO,MAAM,QAAQ,IAAI,CAAC;MACpD;IACD;AAEA,QAAI,OAAO,mBAAmB,OAAO;AACpC,yBAAmB,IAAI;IACxB;EACD;;;;;;EAhDQ,UAAU;AACjB,WAAO,cAAc,EAAE,KAAK,OAAA;EAC7B;;;;;;;;;;;;;;;;;;EAiEO,IACN,MACA,MACA,SACY;AACZ,QAAI,OAAO,SAAS,YAAY,MAAM,QAAQ,IAAI,GAAG;AACpD,YAAM,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,IAAI;AAChD,aAAO,KAAK,iBAAiB,IAAI,EAAE,OAAO,MAAM,MAAM,SAAS,MAAkB;IAClF;AAGA,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,MAAM,KAAK,QAAQ;AACzB,YAAM,OAAO,IAAI,KAAI,IAAI;AACzB,aAAO,KAAK,mBAAmB,KAAK,IAAI,EAAE,IAAI,KAAK,MAAM,OAAO;IACjE;AAEA,UAAM,IAAI,MAAM;EAAuD,KAAK,UAAU,IAAI,CAAA,EAAG;EAC9F;;;;;;;;;;;;;;EAeO,GACN,MACA,MACA,UACM;AACN,QAAI,OAAO,SAAS,UAAU;AAC7B,UAAI,UAAU;AACb,eAAO,UAAU,MAAM,QAAQ;MAChC,OAAO;AACN,cAAM,IAAI,MAAM,gDAAgD;MACjE;IACD;AAGA,QAAI,OAAO,SAAS,YAAY,MAAM,QAAQ,IAAI,GAAG;AACpD,YAAM,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,IAAI;AAChD,aAAO,KAAK,iBAAiB,IAAI,EAAE,OAAO,MAAM,MAAM,MAAkB;IACzE;AAGA,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,OAAO,IAAI,KAAI,IAAI;AACzB,YAAM,MAAM,KAAK,QAAQ;AACzB,aAAO,KAAK,mBAAmB,KAAK,IAAI,EAAE,GAAG,KAAK,MAAM,QAAQ;IACjE;AAEA,UAAM,IAAI,MAAM;EAAsD,KAAK,UAAU,IAAI,CAAA,EAAG;EAC7F;;;;;;EAOO,QAAQ,MAAuB;AACrC,WAAO,KAAK,MAAM,IAAI,IAAI;EAC3B;;;;;;;;;;;;;;;EAgBO,cAAc,MAAc,SAAsB;AACxD,SAAK,MAAM,IAAI,MAAM,OAAO;AAC5B,WAAO;EACR;;;;;;;;;;;;;;;;;;;;;;;EAwBO,aACN,UACA,UAMA,UAKA,aAAqC,MAAM,MACrC;AACN,UAAM,EAAE,MAAM,QAAQ,SAAS,IAAI,KAAK,cAAc,QAAQ;AAE9D,SAAK,MAAM,IAAI,MAAM;MACpB,OAAO,MAAW,MAAM,SAA2B,YAAY;AAC9D,cAAM,UAAW,SAAsB,OAAO,CAAC,KAAU,OAAe,UAAU;AACjF,iBAAO,OAAO,OAAO,KAAK,EAAE,CAAC,KAAK,GAAG,WAAW,KAAK,EAAE,CAAC;QACzD,GAAG,CAAC,CAAC;AAEL,eAAO,KAAK,WAAW,KAAK,MAAM,IAAI,UAAU,OAAO,GAAG,MAAM,YAAY,OAAO;MACpF;MACA,OAAO,MAAW,MAAM,YAAY;AACnC,cAAM,UAAW,SAAsB,OAAO,CAAC,KAAU,OAAe,UAAU;AACjF,iBAAO,OAAO,OAAO,KAAK,EAAE,CAAC,KAAK,GAAG,WAAW,KAAK,EAAE,CAAC;QACzD,GAAG,CAAC,CAAC;AAEL,eAAO,KAAK,WAAW,KAAK,MAAM,IAAI,UAAU,IAAI,GAAG,YAAY,OAAO;MAC3E;;;MAIA,WAAW,QAAQ,MAAM,YAAY,SAAS;AAC7C,YAAI,WAAW,IAAI,GAAG;AACrB,iBAAO,SAAS,KAAK,MAAM,QAAQ,MAAM,YAAY,OAAO;QAC7D,OAAO;AACN,gBAAM,IAAI,MAAM,8BAA8B,IAAA,WAAe,IAAA,EAAM;QACpE;MACD;MACA,WAAW,QAAQ,YAAY,SAAS;AACvC,eAAO,SAAS,KAAK,MAAM,QAAQ,YAAY,OAAO;MACvD;IACD,CAAkB;AAElB,WAAO;EACR;;;;;;;;;;;;;;;;;;;;;EAsBO,gBACN,UACA,YACC;AACD,SAAK;MACJ;MACA,CAAC,QAAQ,MAAM,eAAe;AAC7B,cAAM,WAAW,WAAW;UAC3B,CAAC,UACA,IAAI,QAAiB;YACpB,MAAM,OAAO,KAAK;YAClB,OAAO,CAACC,OAAMC,YAAW;AACxB,oBAAM,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,KAAK;AACjD,oBAAM,gBAAgB,KAAK,iBAAiB,IAAI;AAEhD,oBAAM,UAAW,OAAoB,OAAO,CAAC,KAAU,OAAe,UAAU;AAC/E,uBAAO,OAAO,OAAO,KAAK,EAAE,CAAC,KAAK,GAAG,WAAW,KAAK,EAAE,CAAC;cACzD,GAAG,CAAC,CAAC;AAEL,qBAAO,cAAc,WAAW,KAAK,MAAMA,SAAQD,OAAM,QAAQ,OAAO;YACzE;YACA,MAAM,MAAM;AACX,oBAAM,IAAI,MAAM,iBAAiB;YAClC;UACD,CAAC;QACH;AAEA,mBAAW,GAAG,QAAQ,EAAE,MAAM,MAAM,MAAM;AAC1C,eAAO;MACR;MACA,CAAC,QAAQ,eAAe;AACvB,cAAM,WAAW,WAAW;UAC3B,CAAC,UACA,IAAI,QAAiB;YACpB,MAAM,OAAO,KAAK;YAClB,OAAO,CAAC,OAAO,YAAY;AAC1B,oBAAM,IAAI,MAAM,iBAAiB;YAClC;YACA,MAAM,CAACE,YAAW;AACjB,oBAAM,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,KAAK;AACjD,oBAAM,gBAAgB,KAAK,iBAAiB,IAAI;AAEhD,oBAAM,UAAW,OAAoB,OAAO,CAAC,KAAU,OAAe,UAAU;AAC/E,uBAAO,OAAO,OAAO,KAAK,EAAE,CAAC,KAAK,GAAG,WAAW,KAAK,EAAE,CAAC;cACzD,GAAG,CAAC,CAAC;AAEL,qBAAO,cAAc,WAAW,KAAK,MAAMA,SAAQ,QAAQ,OAAO;YACnE;UACD,CAAC;QACH;AAEA,eAAO,WAAW,GAAG,QAAQ,EAAE,KAAK,MAAM;MAC3C;IACD;AAEA,WAAO;EACR;;;;;;;;;;;;EAaO,oBAAoB,MAAc,QAAgB,WAA4B,OAAY;AAChG,YAAQ,UAAU;MACjB,KAAK;AACJ,eAAO,KAAK;UACX;UACA,SAAS,cAAc,QAAQ,MAAc;AAC5C,mBAAO,QAAQ,IAAI,EAAE,OAAO,CAACD,SAAQ,OAAOA,QAAO,OAAO,EAAE,GAAG,MAAM;UACtE;UACA,SAAS,cAAc,QAAQ;AAC9B,mBAAO,MAAM,OAAO,UAAU,MAAM,CAAC;UACtC;QACD;MACD,KAAK;AACJ,eAAO,KAAK;UACX;UACA,SAAS,cAAc,QAAQ,MAAc;AAC5C,mBAAO,QAAQ,IAAI,EAAE,OAAO,CAACA,SAAQ,OAAOA,QAAO,OAAO,EAAE,GAAG,MAAM;UACtE;UACA,SAAS,cAAc,QAAQ;AAC9B,mBAAO,MAAM,OAAO,UAAU,MAAM,CAAC;UACtC;QACD;MACD;AACC,cAAM,IAAI,MAAM,gDAAgD;IAClE;EACD;;;;;;;;;;;;;EAcQ,mBAAmB,UAAuB;AACjD,QAAI,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,QAAQ;AAClD,QAAI,OAAO,SAAS,GAAG;AACtB,YAAM,IAAI,MAAM,kDAAkD,IAAI;IACvE;AAEA,WAAO,KAAK;MACX;MACA,SAAS,aAER,QACA,MACA,YACA,SACC;AACD,eAAO,OAAO,SAAS,MAAM,CAACA,SAAQ,OAAO;AAC5C,cAAI,cAAwB,WAAW,CAAC;AACxC,cAAI,CAAC,aAAa;AACjB,kBAAM,IAAI,MAAM,2DAA2D,QAAA,GAAW;UACvF;AAEA,cAAI,EAAE,MAAAE,OAAM,QAAAC,QAAO,IAAI,KAAK,cAAc,WAAW;AACrD,cAAI,KAAK,QAAQD,KAAI,GAAG;AACvB,mBAAO,KAAK,iBAAiBA,KAAI,EAAE,WAAW,KAAK,MAAMF,SAAQ,IAAIG,SAAQ,OAAO;UACrF;AAEA,cAAI,EAAED,SAAQ,UAAU;AACvB,kBAAM,IAAI;cACT,iDAAiDA,KAAAA;YAClD;UACD;AAEA,cAAI,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK,cAAc,QAAQA,KAAI,CAAC;AAE/E,iBAAO,KAAK,iBAAiB,SAAS,EAAE,WAAW;YAClD;YACAF;YACA;YACA;YACA;UACD;QACD,CAAC;MACF;MACA,SAAS,aAAwB,QAAmB,YAAY,SAAS;AACxE,eAAO,OAAO,QAAQ,CAACC,YAAW;AACjC,cAAI,cAAwB,WAAW,CAAC;AACxC,cAAI,CAAC,aAAa;AACjB,kBAAM,IAAI,MAAM,2DAA2D,QAAA,GAAW;UACvF;AAEA,cAAI,EAAE,MAAAC,OAAM,QAAAC,QAAO,IAAI,KAAK,cAAc,WAAW;AACrD,cAAI,KAAK,QAAQD,KAAI,GAAG;AACvB,mBAAO,KAAK,iBAAiBA,KAAI,EAAE,WAAW,KAAK,MAAMD,SAAQE,SAAQ,OAAO;UACjF;AAEA,cAAI,EAAED,SAAQ,UAAU;AACvB,kBAAM,IAAI;cACT,iDAAiDA,KAAAA;YAClD;UACD;AAEA,cAAI,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK,cAAc,QAAQA,KAAI,CAAC;AAE/E,iBAAO,KAAK,iBAAiB,SAAS,EAAE,WAAW;YAClD;YACAD;YACA;YACA;UACD;QACD,CAAC;MACF;IACD;EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8CO,mBAAmB,UAAoB,QAAmC;AAGhF,aAAS,OAAO,QAAQ;AACvB,UAAI,eAAe,KAAK,QAAQ;AAChC,UAAI,QAAQ,OAAO,GAAG;AAGtB,UAAI,CAAC,MAAM,QAAQ,KAAK,KAAK,OAAO,UAAU,UAAU;AACvD,eAAO,GAAG,IAAI;AACd,aAAK,mBAAmB,cAAc,KAA6B;MACpE;IACD;AAEA,QAAI,SAAS,OAAO,OAAO,MAAM;AAKjC,QAAI,iBAAiB,OAAO,KAAK,MAAM;AAIvC,QAAI,EAAE,MAAM,YAAY,QAAQ,SAAS,IAAI,KAAK,cAAc,QAAQ;AAIxE,WAAO,KAAK;MACX;MACA,SAAS,aAER,QACA,MACA,YACA,SACC;AACD,YAAI,CAAC,QAAQ,KAAK,gBAAgB,QAAQ;AACzC,gBAAM,IAAI,MAAM,YAAY,UAAA,0BAAoC,IAAA,EAAM;QACvE;AAEA,YAAI,WAAW,WAAW,SAAS,QAAQ;AAC1C,gBAAM,IAAI;YACT,4DAA4D,SAAS,MAAA,UAAgB,WAAW,MAAA;UACjG;QACD;AAGA,iBAAS,OAAO,gBAAgB;AAC/B,cAAI,EAAE,OAAO,OAAO;AACnB,kBAAM,IAAI,MAAM,UAAU,UAAA,mBAA6B,GAAA,IAAO,OAAO,GAAG,CAAA,EAAG;UAC5E;AAGA,gBAAM,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK;YACrD,OAAO,GAAG;UACX;AAKA,cAAI,CAAC,SAAS,SAAS,SAAS,GAAG;AAClC,iBAAK,iBAAiB,SAAS,EAAE,WAAW;cAC3C;cACA;cACA,KAAK,GAAG;cACR;cACA;YACD;UACD,OAAO;AACN,kBAAM,WAAW,SAAS,QAAQ,SAAS;AAC3C,gBAAI,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,WAAW,QAAQ,CAAC;AAI9D,gBAAI,KAAK,QAAQ,IAAI,GAAG;AACvB,mBAAK,iBAAiB,IAAI,EAAE,WAAW;gBACtC;gBACA;gBACA,KAAK,GAAG;gBACR;gBACA;cACD;AACA;YACD;AAGA,gBAAI,EAAE,QAAQ,UAAU;AACvB,oBAAM,IAAI;gBACT,iDAAiD,IAAA,OAAW,UAAA;cAC7D;YACD;AAEA,gBAAI,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK,cAAc,QAAQ,IAAI,CAAC;AAC/E,iBAAK,iBAAiB,SAAS,EAAE,WAAW;cAC3C;cACA;cACA,KAAK,GAAG;cACR;cACA;YACD;UACD;QACD;AACA,eAAO;MACR;MACA,SAAS,aAAwB,QAAmB,YAAY,SAAS;AACxE,YAAI,WAAW,WAAW,SAAS,QAAQ;AAC1C,gBAAM,IAAI;YACT,4DAA4D,SAAS,MAAA,UAAgB,WAAW,MAAA;UACjG;QACD;AAEA,YAAI,SAAiC,CAAC;AACtC,iBAAS,OAAO,gBAAgB;AAC/B,gBAAM,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK;YACrD,OAAO,GAAG;UACX;AAGA,cAAI,CAAC,SAAS,SAAS,SAAS,GAAG;AAClC,mBAAO,GAAG,IAAI,KAAK,iBAAiB,SAAS,EAAE,WAAW;cACzD;cACA;cACA;cACA;YACD;UACD,OAAO;AACN,kBAAM,WAAW,SAAS,QAAQ,SAAS;AAC3C,gBAAI,EAAE,MAAM,OAAO,IAAI,KAAK,cAAc,WAAW,QAAQ,CAAC;AAI9D,gBAAI,KAAK,QAAQ,IAAI,GAAG;AACvB,qBAAO,GAAG,IAAI,KAAK,iBAAiB,IAAI,EAAE,WAAW;gBACpD;gBACA;gBACA;gBACA;cACD;AACA;YACD;AAEA,gBAAI,EAAE,QAAQ,UAAU;AACvB,oBAAM,IAAI;gBACT,iDAAiD,IAAA,OAAW,UAAA;cAC7D;YACD;AAEA,gBAAI,EAAE,MAAM,WAAW,QAAQ,YAAY,IAAI,KAAK,cAAc,QAAQ,IAAI,CAAC;AAC/E,mBAAO,GAAG,IAAI,KAAK,iBAAiB,SAAS,EAAE,WAAW;cACzD;cACA;cACA;cACA;YACD;UACD;QACD;AACA,eAAO;MACR;IACD;EACD;;;;;;;;;;;;;;;;;;;;;;;EAwBO,iBAAiB,UAAoB,UAAmC;AAG9E,aAAS,OAAO,UAAU;AACzB,UAAI,eAAe,KAAK,QAAQ;AAChC,UAAI,QAAQ,SAAS,GAAG;AAExB,UAAI,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK,KAAK,OAAO,UAAU,UAAU;AACzE,iBAAS,GAAG,IAAI;AAChB,aAAK,mBAAmB,cAAc,KAA6B;MACpE;IACD;AAEA,QAAI,SAAS,OAAO,OAAO,QAAQ;AAGnC,QAAI,iBAAiB,OAAO,KAAK,MAAM;AAGvC,QAAI,EAAE,MAAM,QAAQ,oBAAoB,IAAI,KAAK,cAAc,QAAQ;AAEvE,WAAO,KAAK;MACX;MACA,SAAS,WAER,QACA,MACA,YACA,SACC;AACD,YAAI,CAAC,MAAM;AACV,gBAAM,IAAI,MAAM,yBAAyB,IAAA;aAAoC,IAAA,GAAO;QACrF;AACA,YAAI,OAAO,SAAS,UAAU;AAC7B,gBAAM,IAAI;YACT,oCAAoC,IAAA,wCAA4C,eAAe;cAC9F;YACD,CAAA;aAAmB,KAAK,UAAU,IAAI,CAAA;UACvC;QACD;AAEA,YAAI,MAAM,OAAO,KAAK,IAAI,EAAE,CAAC;AAC7B,YAAI,QAAQ,QAAW;AACtB,gBAAM,IAAI,MAAM,iDAAiD,IAAA,GAAO;QACzE;AAEA,YAAI,YAAY,eAAe,QAAQ,GAAG;AAC1C,YAAI,cAAc,IAAI;AACrB,gBAAM,IAAI;YACT,kCAAkC,IAAA,uBAA2B,eAAe;cAC3E;YACD,CAAA,gBAAiB,GAAA;UAClB;QACD;AACA,YAAI,YAAY,eAAe,SAAS;AACxC,YAAI,gBAAgB,OAAO,SAAS;AAGpC,eAAO,OAAO,SAAS;AAGvB,YAAI,kBAAkB,MAAM;AAC3B,iBAAO;QACR;AAEA,YAAI,aAAa,oBAAoB,QAAQ,aAAa;AAC1D,YAAI,cAAc,eAAe,KAAK,gBAAgB,WAAW,UAAU;AAE3E;AACC,cAAI,EAAE,MAAAC,OAAM,OAAO,IAAI,KAAK,cAAc,WAAW;AACrD,iBAAO,KAAK,iBAAiBA,KAAI,EAAE,WAAW;YAC7C;YACA;YACA,KAAK,GAAG;YACR;YACA;UACD;QACD;MACD;MACA,SAAS,WAAsB,QAAmB,YAAY,SAAS;AACtE,YAAI,YAAY,OAAO,SAAS;AAChC,YAAI,YAAY,eAAe,SAAS;AACxC,YAAI,gBAAgB,OAAO,SAAS;AAEpC,YAAI,cAAc,IAAI;AACrB,gBAAM,IAAI;YACT,0CAA0C,IAAA,gCAAoC,SAAA;UAC/E;QACD;AAGA,YAAI,kBAAkB,MAAM;AAC3B,iBAAO,EAAE,CAAC,SAAS,GAAG,KAAK;QAC5B;AAEA,YAAI,aAAa,oBAAoB,QAAQ,aAAa;AAC1D,YAAI,cAAc,eAAe,KAAK,gBAAgB,WAAW,UAAU;AAE3E;AACC,cAAI,EAAE,MAAAA,OAAM,OAAO,IAAI,KAAK,cAAc,WAAW;AACrD,iBAAO;YACN,CAAC,SAAS,GAAG,KAAK,iBAAiBA,KAAI,EAAE,WAAW,KAAK,MAAM,QAAQ,QAAQ,OAAO;UACvF;QACD;MACD;IACD;EACD;;;;;;;;EAQO,iBAAiB,MAA6B;AACpD,QAAI,gBAAgB,KAAK,MAAM,IAAI,IAAI;AAIvC,QAAI,OAAO,kBAAkB,UAAU;AACtC,UAAI,QAAkB,CAAC;AACvB,aAAO,OAAO,kBAAkB,UAAU;AACzC,YAAI,MAAM,SAAS,aAAa,GAAG;AAClC,gBAAM,IAAI,MAAM,+BAA+B,MAAM,KAAK,MAAM,CAAA,OAAQ,aAAA,EAAe;QACxF;AACA,cAAM,KAAK,aAAa;AACxB,wBAAgB,KAAK,MAAM,IAAI,aAAa;MAC7C;IACD;AAEA,QAAI,kBAAkB,QAAW;AAChC,YAAM,IAAI,MAAM,QAAQ,IAAA,oBAAwB;IACjD;AAEA,WAAO;EACR;;;;;;;;;;;EAYO,cAAc,MAGnB;AACD,QAAI,MAAM,QAAQ,IAAI,GAAG;AACxB,UAAI,CAACE,WAAU,GAAGD,OAAM,IAAI;AAC5B,aAAO,EAAE,MAAMC,WAAU,QAAAD,QAAO;IACjC;AAEA,QAAI,OAAO,SAAS,UAAU;AAC7B,YAAM,IAAI,MAAM,8CAA8C,IAAA,EAAM;IACrE;AAEA,QAAI,CAAC,MAAM,KAAK,IAAI,KAAK,OAAO,qBAAqB,CAAC,KAAK,GAAG;AAE9D,QAAI,UAAU,KAAK,QAAQ,IAAI;AAC/B,QAAI,UAAU,MAAM,KAAK,IAAI,EAAE,QAAQ,EAAE,QAAQ,KAAK;AAGtD,QAAI,YAAY,MAAM,YAAY,IAAI;AACrC,aAAO,EAAE,MAAY,QAAQ,CAAC,EAAE;IACjC;AAGA,QAAI,YAAY,MAAM,YAAY,IAAI;AACrC,YAAM,IAAI,MAAM,6BAA6B,IAAA,GAAO;IACrD;AAEA,QAAI,WAAW,KAAK,MAAM,GAAG,OAAO;AACpC,QAAI,SAAS;MACZ,KAAK,MAAM,UAAU,GAAG,KAAK,SAAS,UAAU,CAAC;MACjD,KAAK,OAAO;IACb;AAEA,WAAO,EAAE,MAAM,UAAU,OAAO;EACjC;AACD;AAh3BO,IAAM,MAAN;AAAM,IAEI,KAAK;AAFT,IAGI,MAAM;AAHV,IAII,MAAM;AAJV,IAKI,MAAM;AALV,IAMI,OAAO;AANX,IAOI,OAAO;AAPX,IAQI,OAAO;AARX,IASI,SAAS;AATb,IAUI,UAAU;AAVd,IAWI,SAAS;AAXb,IAYI,MAAM;AAZV,IAaI,SAAS;AAbb,IAcI,SAAS;AAy2BnB,SAAS,mBAAmBE,MAAgB;AAClD,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,OAAO,IAAI;IAC1B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,MAAM;IACrB;IACA,CAAC,OAAO,KAAK;EACd;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,QAAQ,IAAI;IAC3B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,OAAO;IACtB;IACA,CAAC,QAAQ,MAAM;EAChB;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,QAAQ,IAAI;IAC3B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,OAAO;IACtB;IACA,CAAC,QAAQ,OAAO;EACjB;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,QAAQ,IAAI;IAC3B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,OAAO;IACtB;EACD;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAc;AAC1C,aAAO,OAAO,SAAS,IAAI;IAC5B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,QAAQ;IACvB;EACD;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,SAAS,IAAI;IAC5B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,QAAQ;IACvB;EACD;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAM;AAClC,aAAO,OAAO,OAAO,IAAI;IAC1B;IACA,SAAU,QAAmB;AAC5B,aAAO,OAAO,MAAM,EAAE,SAAS,EAAE,MAAM;IACxC;EACD;AAEA,EAAAA,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAc;AAC1C,aAAO,OAAO,SAAS,MAAM,KAAK,IAAI,GAAG,CAACL,SAAQ,OAAOA,QAAO,OAAO,GAAG,WAAW,CAAC,CAAC,CAAC;IACzF;IACA,SAAU,QAAmB;AAC5B,aAAO,OACL,QAAQ,CAACC,YAAWA,QAAO,MAAM,CAAC,EAClC,IAAI,CAAC,OAAe,OAAO,aAAa,OAAO,EAAE,CAAC,CAAC,EACnD,KAAK,EAAE;IACV;IACA,CAAC,SAAiB;EACnB;AAEA,EAAAI,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAc;AAC1C,aAAO,OAAO,SAAS,MAAM,KAAK,QAAQ,IAAI,CAAC,GAAG,CAACL,SAAQ,OAAOA,QAAO,OAAO,EAAE,CAAC;IACpF;IACA,SAAU,QAAmB;AAC5B,UAAI,QAAQ,OAAO,QAAQ,CAACC,YAAWA,QAAO,MAAM,CAAC;AACrD,aAAO,MAAM,IAAI,WAAW,KAAK,CAAC;IACnC;EACD;AAEA,EAAAI,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAc;AAC1C,aAAO,OAAO,SAAS,MAAM,KAAK,QAAQ,IAAI,CAAC,GAAG,CAACL,SAAQ,OAAOA,QAAO,OAAO,EAAE,CAAC;IACpF;IACA,SAAU,QAAmB;AAC5B,UAAI,QAAQ,OAAO,QAAQ,CAACC,YAAWA,QAAO,MAAM,CAAC;AACrD,aAAO,MAAM,IAAI,WAAW,KAAK,CAAC;IACnC;EACD;AAEA,EAAAI,KAAI;IACH,IAAI;IACJ,SAAU,QAAmB,MAAc;AAC1C,aAAO,OAAO,SAAS,MAAM,KAAK,QAAQ,IAAI,CAAC,GAAG,CAACL,SAAQ,OAAOA,QAAO,OAAO,EAAE,CAAC;IACpF;IACA,SAAU,QAAmB;AAC5B,UAAI,QAAQ,OAAO,QAAQ,CAACC,YAAWA,QAAO,MAAM,CAAC;AACrD,aAAO,MAAM,IAAI,WAAW,KAAK,CAAC;IACnC;EACD;AACD;AAWO,SAAS,mBAA8B;AAC7C,SAAO;IACN,mBAAmB,CAAC,KAAK,GAAG;IAC5B,YAAY;IACZ,eAAe;IACf,iBAAiB;EAClB;AACD;;;AChmCO,IAAMK,sBAAqB;AAC3B,SAAS,kBAAkB,OAAgC;AACjE,SAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAMA;AACpD;AAiEO,SAAS,oBAAoB,OAAe,aAAsB,OAAe;AACvF,MAAI,UAAU,MAAM,YAAY;AAChC,MAAI,CAAC,cAAc,QAAQ,WAAW,IAAI,GAAG;AAC5C,cAAU,QAAQ,MAAM,CAAC;EAC1B;AACA,SAAO,KAAK,QAAQ,SAASC,sBAAqB,GAAG,GAAG,CAAA;AACzD;AAEO,SAAS,qBAAqB,OAAe,aAAsB,OAAe;AACxF,SAAO,oBAAoB,OAAO,UAAU;AAC7C;AAEA,SAAS,MAAM,OAAwB;AACtC,SAAO,yBAAyB,KAAK,KAAK,KAAK,MAAM,SAAS,MAAM;AACrE;AAEA,SAAS,iBAAiB,OAAuB;AAChD,SAAO,WAAW,KAAK,KAAK,KAAK,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS;AACzE;;;ACrFM,IAAO,cAAP,cAA2B,UAAS;EAUxC,YAAY,SAAkB,UAAkC;AAC9D,QAAI;AACJ,UAAM,EAAE,SAAS,aAAa,GAAG,KAAI,IAAK;AAC1C,UAAM,EAAE,KAAI,IAAK;AACjB,UAAM,MACJ,KAAK,WAAW,IAAI,UAAU,YAAY,KAAK,KAAK,GAAG,CAAC,OAAO,OAAO;AACxE,UAAM,eAAe,GAAG;AACxB,QAAI,eAAe;AAAM,WAAK,QAAQ;AACtC,WAAO,OAAO,MAAM,IAAI;AACxB,SAAK,OAAO,KAAK,YAAY;AAC7B,SAAK,WAAW,MAAK;AACnB,aAAQ,WAAA,SAAW,CAAC,SAAS,GAAG,SAAQ,CAAE;IAC5C;;AAEH;ACzCD,SAAS,WAAc,GAAU;AAC/B,SAAO,SAAS,CAAC,KAAK,OAAO,EAAE,OAAO,QAAQ,MAAM;AACtD;AAMM,SAAU,SAAS,GAAU;AACjC,SAAO,OAAO,MAAM,YAAY,KAAK;AACvC;AAmBM,SAAU,MAAM,OAAU;AAC9B,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,MAAM,SAAQ;EACtB;AAED,SAAO,OAAO,UAAU,WAAW,KAAK,UAAU,KAAK,IAAI,GAAG,KAAK;AACrE;AAOM,SAAU,cAAiB,OAAkB;AACjD,QAAM,EAAE,MAAM,MAAK,IAAK,MAAM,KAAI;AAClC,SAAO,OAAO,SAAY;AAC5B;AAMM,SAAU,UACd,QACA,SACA,QACA,OAAU;AAEV,MAAI,WAAW,MAAM;AACnB;EACD,WAAU,WAAW,OAAO;AAC3B,aAAS,CAAA;EACV,WAAU,OAAO,WAAW,UAAU;AACrC,aAAS,EAAE,SAAS,OAAM;EAC3B;AAED,QAAM,EAAE,MAAM,OAAM,IAAK;AACzB,QAAM,EAAE,KAAI,IAAK;AACjB,QAAM,EACJ,YACA,UAAU,8BAA8B,IAAI,KAC1C,aAAa,sBAAsB,UAAU,OAAO,EACtD,qBAAqB,MAAM,KAAK,CAAC,KAAI,IACnC;AAEJ,SAAO;IACL;IACA;IACA;IACA,KAAK,KAAK,KAAK,SAAS,CAAC;IACzB;IACA;IACA,GAAG;IACH;;AAEJ;AAMM,UAAW,WACf,QACA,SACA,QACA,OAAU;AAEV,MAAI,CAAC,WAAW,MAAM,GAAG;AACvB,aAAS,CAAC,MAAM;EACjB;AAED,aAAW,KAAK,QAAQ;AACtB,UAAM,UAAU,UAAU,GAAG,SAAS,QAAQ,KAAK;AAEnD,QAAI,SAAS;AACX,YAAM;IACP;EACF;AACH;AAOM,UAAW,IACf,OACA,QACA,UAMI,CAAA,GAAE;AAEN,QAAM,EAAE,OAAO,CAAA,GAAI,SAAS,CAAC,KAAK,GAAG,SAAS,OAAO,MAAAC,QAAO,MAAK,IAAK;AACtE,QAAM,MAAe,EAAE,MAAM,OAAM;AAEnC,MAAI,QAAQ;AACV,YAAQ,OAAO,QAAQ,OAAO,GAAG;AAEjC,QACEA,SACA,OAAO,SAAS,UAChB,SAAS,OAAO,MAAM,KACtB,SAAS,KAAK,KACd,CAAC,MAAM,QAAQ,KAAK,GACpB;AACA,iBAAW,OAAO,OAAO;AACvB,YAAI,OAAO,OAAO,GAAG,MAAM,QAAW;AACpC,iBAAO,MAAM,GAAG;QACjB;MACF;IACF;EACF;AAED,MAAI,SAAgD;AAEpD,aAAW,WAAW,OAAO,UAAU,OAAO,GAAG,GAAG;AAClD,YAAQ,cAAc,QAAQ;AAC9B,aAAS;AACT,UAAM,CAAC,SAAS,MAAS;EAC1B;AAED,WAAS,CAAC,GAAG,GAAG,CAAC,KAAK,OAAO,QAAQ,OAAO,GAAG,GAAG;AAChD,UAAM,KAAK,IAAI,GAAG,GAAa;MAC7B,MAAM,MAAM,SAAY,OAAO,CAAC,GAAG,MAAM,CAAC;MAC1C,QAAQ,MAAM,SAAY,SAAS,CAAC,GAAG,QAAQ,CAAC;MAChD;MACA,MAAAA;MACA,SAAS,QAAQ;IAClB,CAAA;AAED,eAAW,KAAK,IAAI;AAClB,UAAI,EAAE,CAAC,GAAG;AACR,iBAAS,EAAE,CAAC,EAAE,cAAc,OAAO,gBAAgB;AACnD,cAAM,CAAC,EAAE,CAAC,GAAG,MAAS;MACvB,WAAU,QAAQ;AACjB,YAAI,EAAE,CAAC;AAEP,YAAI,MAAM,QAAW;AACnB,kBAAQ;QACT,WAAU,iBAAiB,KAAK;AAC/B,gBAAM,IAAI,GAAG,CAAC;QACf,WAAU,iBAAiB,KAAK;AAC/B,gBAAM,IAAI,CAAC;QACZ,WAAU,SAAS,KAAK,GAAG;AAC1B,cAAI,MAAM,UAAa,KAAK;AAAO,kBAAM,CAAC,IAAI;QAC/C;MACF;IACF;EACF;AAED,MAAI,WAAW,aAAa;AAC1B,eAAW,WAAW,OAAO,QAAQ,OAAY,GAAG,GAAG;AACrD,cAAQ,cAAc,QAAQ;AAC9B,eAAS;AACT,YAAM,CAAC,SAAS,MAAS;IAC1B;EACF;AAED,MAAI,WAAW,SAAS;AACtB,UAAM,CAAC,QAAW,KAAU;EAC7B;AACH;IChMa,eAAM;EAYjB,YAAY,OAOX;AACC,UAAM,EACJ,MACA,QACA,WACA,SACA,UAAU,CAAC,UAAmB,OAC9B,UAAU,aAAS;IAAA,EAAM,IACvB;AAEJ,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,UAAU;AAEf,QAAI,WAAW;AACb,WAAK,YAAY,CAAC,OAAO,YAAW;AAClC,cAAM,SAAS,UAAU,OAAO,OAAO;AACvC,eAAO,WAAW,QAAQ,SAAS,MAAM,KAAK;MAChD;IACD,OAAM;AACL,WAAK,YAAY,MAAM,CAAA;IACxB;AAED,QAAI,SAAS;AACX,WAAK,UAAU,CAAC,OAAO,YAAW;AAChC,cAAM,SAAS,QAAQ,OAAO,OAAO;AACrC,eAAO,WAAW,QAAQ,SAAS,MAAM,KAAK;MAChD;IACD,OAAM;AACL,WAAK,UAAU,MAAM,CAAA;IACtB;;;;;EAOH,OAAO,OAAgB,SAAgB;AACrC,WAAO,OAAO,OAAO,MAAM,OAAO;;;;;EAOpC,OAAO,OAAgB,SAAgB;AACrC,WAAO,OAAO,OAAO,MAAM,OAAO;;;;;EAOpC,GAAG,OAAc;AACf,WAAO,GAAG,OAAO,IAAI;;;;;;EAQvB,KAAK,OAAgB,SAAgB;AACnC,WAAO,KAAK,OAAO,MAAM,OAAO;;;;;;;;;;EAYlC,SACE,OACA,UAGI,CAAA,GAAE;AAEN,WAAO,SAAS,OAAO,MAAM,OAAO;;AAEvC;SAMe,OACd,OACA,QACA,SAAgB;AAEhB,QAAM,SAAS,SAAS,OAAO,QAAQ,EAAE,QAAO,CAAE;AAElD,MAAI,OAAO,CAAC,GAAG;AACb,UAAM,OAAO,CAAC;EACf;AACH;SAMgB,OACd,OACA,QACA,SAAgB;AAEhB,QAAM,SAAS,SAAS,OAAO,QAAQ,EAAE,QAAQ,MAAM,QAAO,CAAE;AAEhE,MAAI,OAAO,CAAC,GAAG;AACb,UAAM,OAAO,CAAC;EACf,OAAM;AACL,WAAO,OAAO,CAAC;EAChB;AACH;SAMgB,KACd,OACA,QACA,SAAgB;AAEhB,QAAM,SAAS,SAAS,OAAO,QAAQ,EAAE,QAAQ,MAAM,MAAM,MAAM,QAAO,CAAE;AAE5E,MAAI,OAAO,CAAC,GAAG;AACb,UAAM,OAAO,CAAC;EACf,OAAM;AACL,WAAO,OAAO,CAAC;EAChB;AACH;AAMgB,SAAA,GAAS,OAAgB,QAAoB;AAC3D,QAAM,SAAS,SAAS,OAAO,MAAM;AACrC,SAAO,CAAC,OAAO,CAAC;AAClB;AAOM,SAAU,SACd,OACA,QACA,UAII,CAAA,GAAE;AAEN,QAAM,SAAS,IAAI,OAAO,QAAQ,OAAO;AACzC,QAAM,QAAQ,cAAc,MAAM;AAElC,MAAI,MAAM,CAAC,GAAG;AACZ,UAAM,QAAQ,IAAI,YAAY,MAAM,CAAC,GAAG,aAAS;AAC/C,iBAAW,KAAK,QAAQ;AACtB,YAAI,EAAE,CAAC,GAAG;AACR,gBAAM,EAAE,CAAC;QACV;MACF;IACH,CAAC;AAED,WAAO,CAAC,OAAO,MAAS;EACzB,OAAM;AACL,UAAM,IAAI,MAAM,CAAC;AACjB,WAAO,CAAC,QAAW,CAAC;EACrB;AACH;AC9IgB,SAAA,OAAU,MAAc,WAAoB;AAC1D,SAAO,IAAI,OAAO,EAAE,MAAM,MAAM,QAAQ,MAAM,UAAS,CAAE;AAC3D;SClDgB,MAAG;AACjB,SAAO,OAAO,OAAO,MAAM,IAAI;AACjC;AAYM,SAAU,MAA6B,SAAW;AACtD,SAAO,IAAI,OAAO;IAChB,MAAM;IACN,QAAQ;IACR,CAAC,QAAQ,OAAK;AACZ,UAAI,WAAW,MAAM,QAAQ,KAAK,GAAG;AACnC,mBAAW,CAAC,GAAG,CAAC,KAAK,MAAM,QAAO,GAAI;AACpC,gBAAM,CAAC,GAAG,GAAG,OAAO;QACrB;MACF;;IAEH,QAAQ,OAAK;AACX,aAAO,MAAM,QAAQ,KAAK,IAAI,MAAM,MAAK,IAAK;;IAEhD,UAAU,OAAK;AACb,aACE,MAAM,QAAQ,KAAK,KACnB,0CAA0C,MAAM,KAAK,CAAC;;EAG3D,CAAA;AACH;SAMgB,SAAM;AACpB,SAAO,OAAO,UAAU,CAAC,UAAS;AAChC,WAAO,OAAO,UAAU;EAC1B,CAAC;AACH;SAMgB,UAAO;AACrB,SAAO,OAAO,WAAW,CAAC,UAAS;AACjC,WAAO,OAAO,UAAU;EAC1B,CAAC;AACH;SAqFgB,UAAO;AACrB,SAAO,OAAO,WAAW,CAAC,UAAS;AACjC,WACG,OAAO,UAAU,YAAY,CAAC,MAAM,KAAK,KAAK,OAAO,UAAU,KAAK,KACrE,sCAAsC,MAAM,KAAK,CAAC;EAEtD,CAAC;AACH;AAsCM,SAAU,QAAW,UAAW;AACpC,QAAM,cAAc,MAAM,QAAQ;AAClC,QAAM,IAAI,OAAO;AACjB,SAAO,IAAI,OAAO;IAChB,MAAM;IACN,QACE,MAAM,YAAY,MAAM,YAAY,MAAM,YAAY,WAAW;IACnE,UAAU,OAAK;AACb,aACE,UAAU,YACV,0BAA0B,WAAW,qBAAqB,MAAM,KAAK,CAAC;;EAG3E,CAAA;AACH;SAwCgB,QAAK;AACnB,SAAO,OAAO,SAAS,MAAM,KAAK;AACpC;AAMM,SAAU,SAAe,QAAoB;AACjD,SAAO,IAAI,OAAO;IAChB,GAAG;IACH,WAAW,CAAC,OAAO,QAAQ,UAAU,QAAQ,OAAO,UAAU,OAAO,GAAG;IACxE,SAAS,CAAC,OAAO,QAAQ,UAAU,QAAQ,OAAO,QAAQ,OAAO,GAAG;EACrE,CAAA;AACH;SAMgB,SAAM;AACpB,SAAO,OAAO,UAAU,CAAC,UAAS;AAChC,WACG,OAAO,UAAU,YAAY,CAAC,MAAM,KAAK,KAC1C,oCAAoC,MAAM,KAAK,CAAC;EAEpD,CAAC;AACH;AAaM,SAAU,OAA+B,QAAU;AACvD,QAAM,SAAS,SAAS,OAAO,KAAK,MAAM,IAAI,CAAA;AAC9C,QAAM,QAAQ,MAAK;AACnB,SAAO,IAAI,OAAO;IAChB,MAAM;IACN,QAAQ,SAAS,SAAS;IAC1B,CAAC,QAAQ,OAAK;AACZ,UAAI,UAAU,SAAS,KAAK,GAAG;AAC7B,cAAM,WAAW,IAAI,IAAI,OAAO,KAAK,KAAK,CAAC;AAE3C,mBAAW,OAAO,QAAQ;AACxB,mBAAS,OAAO,GAAG;AACnB,gBAAM,CAAC,KAAK,MAAM,GAAG,GAAG,OAAO,GAAG,CAAC;QACpC;AAED,mBAAW,OAAO,UAAU;AAC1B,gBAAM,CAAC,KAAK,MAAM,GAAG,GAAG,KAAK;QAC9B;MACF;;IAEH,UAAU,OAAK;AACb,aACE,SAAS,KAAK,KAAK,qCAAqC,MAAM,KAAK,CAAC;;IAGxE,QAAQ,OAAK;AACX,aAAO,SAAS,KAAK,IAAI,EAAE,GAAG,MAAK,IAAK;;EAE3C,CAAA;AACH;AAMM,SAAU,SAAe,QAAoB;AACjD,SAAO,IAAI,OAAO;IAChB,GAAG;IACH,WAAW,CAAC,OAAO,QACjB,UAAU,UAAa,OAAO,UAAU,OAAO,GAAG;IACpD,SAAS,CAAC,OAAO,QAAQ,UAAU,UAAa,OAAO,QAAQ,OAAO,GAAG;EAC1E,CAAA;AACH;AASgB,SAAA,OACd,KACA,OAAgB;AAEhB,SAAO,IAAI,OAAO;IAChB,MAAM;IACN,QAAQ;IACR,CAAC,QAAQ,OAAK;AACZ,UAAI,SAAS,KAAK,GAAG;AACnB,mBAAW,KAAK,OAAO;AACrB,gBAAM,IAAI,MAAM,CAAC;AACjB,gBAAM,CAAC,GAAG,GAAG,GAAG;AAChB,gBAAM,CAAC,GAAG,GAAG,KAAK;QACnB;MACF;;IAEH,UAAU,OAAK;AACb,aACE,SAAS,KAAK,KAAK,qCAAqC,MAAM,KAAK,CAAC;;EAGzE,CAAA;AACH;SAiDgB,SAAM;AACpB,SAAO,OAAO,UAAU,CAAC,UAAS;AAChC,WACE,OAAO,UAAU,YACjB,oCAAoC,MAAM,KAAK,CAAC;EAEpD,CAAC;AACH;AAqEM,SAAU,MACd,SAAkB;AAElB,QAAM,cAAc,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,KAAK;AACzD,SAAO,IAAI,OAAO;IAChB,MAAM;IACN,QAAQ;IACR,QAAQ,OAAK;AACX,iBAAW,KAAK,SAAS;AACvB,cAAM,CAAC,OAAO,OAAO,IAAI,EAAE,SAAS,OAAO,EAAE,QAAQ,KAAI,CAAE;AAC3D,YAAI,CAAC,OAAO;AACV,iBAAO;QACR;MACF;AAED,aAAO;;IAET,UAAU,OAAO,KAAG;AAClB,YAAM,WAAW,CAAA;AAEjB,iBAAW,KAAK,SAAS;AACvB,cAAM,CAAC,GAAG,MAAM,IAAI,IAAI,OAAO,GAAG,GAAG;AACrC,cAAM,CAAC,KAAK,IAAI;AAEhB,YAAI,CAAC,MAAM,CAAC,GAAG;AACb,iBAAO,CAAA;QACR,OAAM;AACL,qBAAW,CAAC,OAAO,KAAK,QAAQ;AAC9B,gBAAI,SAAS;AACX,uBAAS,KAAK,OAAO;YACtB;UACF;QACF;MACF;AAED,aAAO;QACL,8CAA8C,WAAW,qBAAqB,MAC5E,KAAK,CACN;QACD,GAAG;;;EAGR,CAAA;AACH;SAMgB,UAAO;AACrB,SAAO,OAAO,WAAW,MAAM,IAAI;AACrC;;;AG/fO,IAAM,eAAe,OAAO,GAAU;AAEtC,IAAM,sBAAsB;AAC5B,IAAM,wBAAwB;AAE9B,IAAM,sBAAsB,qBAAqB,KAAK;AAEtD,IAAM,eAAe,GAAG,qBAAA;AACxB,IAAM,6BAAqC,qBAAqB,KAAK;;;AClCrE,SAASC,QAAa,OAAU,QAAyB;AAC/D,SAAO,OAAkB,OAAO,MAAM;AACvC;AAEO,SAAS,wBACf,gBACoC;AACpC,SAAO,OAAO,mBAAmB,YAAY,sBAAsB,iBAChE,eAAe,mBACf;AACJ;AAEO,SAAS,iBACf,gBACoC;AACpC,SAAO,OAAO,mBAAmB,YAAY,eAAe,iBACzD,eAAe,YACf;AACJ;AAEO,SAAS,iBACf,gBACkE;AAClE,MAAI,OAAO,mBAAmB,YAAY,YAAY,gBAAgB;AACrE,WAAO;EACR;AAEA,QAAM,MAAM,iBAAiB,cAAc;AAC3C,QAAM,SAAS,wBAAwB,cAAc;AAErD,MAAI,OAAO,QAAQ,YAAY,YAAY,KAAK;AAC/C,WAAO;EACR;AAEA,MAAI,OAAO,WAAW,YAAY,YAAY,QAAQ;AACrD,WAAO;EACR;AACA,SAAO;AACR;;;ACtCA,IAAM,qBAAqB;AAC3B,IAAM,iBAAiB;AAEvB,IAAM,wBAAwB;AAC9B,IAAM,wBAAwB;AAE9B,IAAM,uBAAuB;AAC7B,IAAM,uBAAuB;AAE7B,IAAM,yBAAyB;AAC/B,IAAM,yBAAyB;AAE/B,IAAM,kBAAkB;EACvB,SAAS;EACT,QAAQ;EACR,MAAM;AACP;AACA,IAAM,qBAAqB;EAC1B,SAAS;EACT,QAAQ;EACR,MAAM;AACP;AACA,IAAM,oBAAoB;EACzB,SAAS;EACT,QAAQ;EACR,MAAM;AACP;AAEA,IAAM,sBAAsB;EAC3B,SAAS;EACT,QAAQ;EACR,MAAM;AACP;AAEA,IAAM,eAAe,CAAC,GAAQ,MAC7B,EAAE,YAAY,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE;AAE3D,SAAS,YAAY,OAAuC;AAzCnE;AA0CC,QAAM,UAAS,sBAAiB,KAAK,MAAtB,mBAAyB;AACxC,UACC,iCAAQ,aAAY,UAAS,iCAAQ,YAAW,iBAAgB,iCAAQ,UAAS;AAEnF;AAEA,SAAS,WAAW,UAAkB,QAAuB;AAC5D,MAAI,OAAO,WAAW,aAAa;AAClC;EACD;AACA,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,IAAI,MAAM,UAAU,MAAA,UAAgB,QAAA,cAAsB,OAAO,MAAA,EAAQ;EAChF;AACD;AAEA,IAAM,eAAe,CAAC,WAAW,QAAQ,MAAM,OAAO,OAAO,OAAO,QAAQ,MAAM;AAE3E,SAAS,yBACf,gBACA,QACqB;AACrB,MAAI,OAAO,mBAAmB,YAAY,aAAa,SAAS,cAAc,GAAG;AAChF,QAAI,kBAAkB,CAAC,MAAM,OAAO,OAAO,OAAO,QAAQ,MAAM,GAAG;AAClE,iBAAW,UAAU,MAAM;IAC5B,WAAW,mBAAmB,QAAQ;AACrC,iBAAW,WAAW,MAAM;IAC7B,WAAW,mBAAmB,WAAW;AACxC,iBAAW,UAAU,MAAM;AAC3B,UAAI,UAAU,CAAC,kBAAkB,MAAgB,GAAG;AACnD,cAAM,IAAI,MAAM,qBAAqB;MACtC;IACD;AACA,WAAO,eAAe,YAAY;EACnC,WAAW,OAAO,mBAAmB,UAAU;AAC9C,UAAM,IAAI,MAAM,gCAAgC,KAAK,UAAU,gBAAgB,MAAM,CAAC,CAAA,EAAG;EAC1F;AAEA,MAAI,YAAY,gBAAgB;AAC/B,SAAK,WAAW,UAAa,OAAO,WAAW,aAAa,eAAe,WAAW,MAAM;AAC3F,aAAO;IACR;AAEA,QAAI,WAAW,UAAa,CAAC,MAAM,QAAQ,MAAM,GAAG;AACnD,YAAM,IAAI,MAAM,UAAU,MAAA,4BAAkC,OAAO,MAAA,EAAQ;IAC5E;AAEA,UAAM,YAAY;MACjB,eAAe;;MAEf,SAAS,OAAO,CAAC,IAAI;IACtB;AAEA,QAAI,cAAc,QAAW;AAC5B;IACD;AAEA,WAAO,UAAU,SAAA;EAClB;AAEA,MAAI,YAAY,gBAAgB;AAC/B,QAAI,aAAa,eAAe,QAAQ,kBAAkB,GAAG;AAC5D,aAAO;IACR,WAAW,aAAa,eAAe,QAAQ,iBAAiB,GAAG;AAClE,aAAO;IACR,WAAW,aAAa,eAAe,QAAQ,eAAe,GAAG;AAChE,aAAO;IACR,WAAW,aAAa,eAAe,QAAQ,mBAAmB,GAAG;AACpE,YAAM,cAAqC;QAC1C,QAAQ,eAAe,OAAO,cAAc,CAAC;MAC9C;AACA,aAAO,yBAAyB,aAAa,MAAM;IACpD;EACD;AAEA,SAAO;AACR;;;ACjHA,IAAM,eAAe;AACrB,IAAM,eAAe;AAEd,IAAM,oBAAN,MAAM,mBAAkB;EAC9B,OAAO,aAAa,KAAa,mBAAmB,OAAgB;AACnE,QAAI,QAAQ,WAAW;AACtB,aAAO,EAAE,SAAS,KAAK;IACxB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,MAAM;AACxB,aAAO,EAAE,IAAI,KAAK;IACnB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,OAAO;AACzB,aAAO,EAAE,KAAK,KAAK;IACpB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,QAAQ;AAC1B,aAAO,EAAE,MAAM,KAAK;IACrB,WAAW,QAAQ,UAAU;AAC5B,aAAO,EAAE,QAAQ,KAAK;IACvB;AACA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AAChB,aAAO;QACN,QAAQ,mBAAkB,aAAa,YAAY,CAAC,GAAG,gBAAgB;MACxE;IACD;AAEA,UAAM,cAAc,IAAI,MAAM,YAAY;AAC1C,QAAI,aAAa;AAChB,YAAM,UAAU,mBAAmB,oBAAoB,YAAY,CAAC,CAAC,IAAI,YAAY,CAAC;AACtF,aAAO;QACN,QAAQ;UACP;UACA,QAAQ,YAAY,CAAC;UACrB,MAAM,YAAY,CAAC;UACnB,YACC,YAAY,CAAC,MAAM,SAChB,CAAC,IACD,mBAAkB,oBAAoB,YAAY,CAAC,GAAG,gBAAgB;QAC3E;MACD;IACD;AAEA,UAAM,IAAI,MAAM,2DAA2D,GAAA,EAAK;EACjF;EAEA,OAAO,oBAAoB,KAAa,mBAAmB,OAAkB;AAC5E,WAAO,uBAAuB,GAAG,EAAE;MAAI,CAAC,QACvC,mBAAkB,aAAa,KAAK,gBAAgB;IACrD;EACD;EAEA,OAAO,YAAY,KAAsB;AACxC,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,QAAQ,KAAK;AAChB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,SAAS,KAAK;AACjB,aAAO;IACR;AACA,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,UAAU,KAAK;AAClB,aAAO;IACR;AACA,QAAI,aAAa,KAAK;AACrB,aAAO;IACR;AACA,QAAI,YAAY,KAAK;AACpB,aAAO;IACR;AACA,QAAI,YAAY,KAAK;AACpB,aAAO,UAAU,mBAAkB,YAAY,IAAI,MAAM,CAAA;IAC1D;AACA,QAAI,YAAY,KAAK;AACpB,YAAM,SAAS,IAAI;AACnB,YAAM,aAAa,OAAO,WAAW,IAAI,mBAAkB,WAAW,EAAE,KAAK,IAAI;AACjF,aAAO,GAAG,OAAO,OAAA,KAAY,OAAO,MAAA,KAAW,OAAO,IAAA,GACrD,aAAa,IAAI,UAAA,MAAgB,EAAA;IAEnC;AACA,UAAM,IAAI,MAAM,iBAAiB;EAClC;AACD;;;AC4BA,IAAM,cAAc,IAAI,IAAY;EACnC,GAAG,iBAAiB;EACpB,OAAO;IACN,OAAO;MACN,aAAa;QACZ,MAAM;QACN,MAAM;MACP;IACD;EACD;AACD,CAAC;AAED,SAAS,WAAW,SAAkC;AACrD,SAAO,IACL,IAAI;IACJ,MAAM;IACN,GAAI;EACL,CAAC,EACA,UAAU;IACV,OAAO,CAAC,QAAgB;IACxB,QAAQ,CAAC,QAAQ,OAAO,GAAG;EAC5B,CAAC;AACH;AAEA,SAAS,WAAwC,MAAS;AACzD,SAAO,IAAI,KAAK,UAAU;IACzB,MAAM;IACN,MAAM;EACP,CAAC;AACF;AAWA,SAAS,SAAiD,MAAyB;AAMlF,SAAO,KAAK,UAAU;IACrB,OAAO,CAAC,SACN;MACA,CAAC,IAAI,IAAI,GAAG;IACb;IACD,QAAQ,CAAC,QAAQ;AAChB,YAAM,MAAM,OAAO,KAAK,GAAG,EAAE,CAAC;AAE9B,aAAO,EAAE,MAAM,KAAK,GAAG,IAAI,GAAG,EAAE;IACjC;EACD,CAAC;AACF;AAEA,IAAM,UAAU,IAAI,MAAMC,mBAAkB,EAAE,UAAU;EACvD,OAAO,CAAC,QACP,OAAO,QAAQ,WAAW,QAAQ,oBAAoB,GAAG,CAAC,IAAI;EAC/D,QAAQ,CAAC,QAAQ,oBAAoB,MAAM,GAAG,CAAC;AAChD,CAAC;AAED,IAAM,eAAe,IAAI,OAAO,IAAI,GAAG,CAAC,EAAE,UAAU;EACnD,MAAM;EACN,OAAO,CAAC,UAAkB,QAAQ,KAAK;EACvC,QAAQ,CAAC,UAAU,MAAM,IAAI,WAAW,KAAK,CAAC;AAC/C,CAAC;AAED,IAAM,eAAe,IAAI,OAAO,gBAAgB;EAC/C,UAAU;EACV,SAAS,IAAI,IAAI;EACjB,QAAQ;AACT,CAAC;AAED,IAAM,kBAAkB,IAAI,OAAO,mBAAmB;EACrD,UAAU;EACV,sBAAsB,IAAI,IAAI;EAC9B,SAAS,IAAI,KAAK;AACnB,CAAC;AAED,IAAM,YAAY,IAAI,KAAK,aAAa;EACvC,YAAY;EACZ,QAAQ;EACR,WAAW;AACZ,CAAC;AAED,IAAM,UAAU,IAAI,KAAK,WAAW;EACnC,MAAM,IAAI,OAAO,IAAI,GAAG,CAAC;EACzB,QAAQ;EACR,QAAQ,IAAI,OAAO,SAAS;AAC7B,CAAC;AAED,IAAM,UAA4B,IAAI,KAAK,WAAW;EACrD,MAAM;EACN,IAAI;EACJ,KAAK;EACL,MAAM;EACN,SAAS;EACT,QAAQ;EACR,QAAQ,IAAI,KAAK,MAAM,OAAO;EAC9B,QAAQ,IAAI,KAAK,MAAM,SAAS;EAChC,KAAK;EACL,KAAK;EACL,MAAM;AACP,CAAC;AAED,IAAM,WAAW;EAChB,IAAI,KAAK,YAAY;IACpB,SAAS;IACT,OAAO,IAAI,OAAO,SAAS,EAAE,OAAO,IAAI,IAAI,EAAE,CAAC;IAC/C,QAAQ,IAAI,OAAO,UAAU,EAAE,OAAO,IAAI,IAAI,EAAE,CAAC;IACjD,cAAc,IAAI,OAAO,gBAAgB,EAAE,OAAO,IAAI,IAAI,GAAG,aAAa,IAAI,IAAI,EAAE,CAAC;EACtF,CAAC;AACF;AAGA,IAAM,uBAAuB,IAC3B,OAAO,wBAAwB;EAC/B,SAAS;EACT,QAAQ,IAAI,OAAO;EACnB,UAAU,IAAI,OAAO;EACrB,gBAAgB,IAAI,OAAO,OAAO;EAClC,WAAW,IAAI,OAAO,QAAQ;AAC/B,CAAC,EACA,UAAU;EACV,OAAO,CAAC,SAA8B;AACrC,UAAM,CAAC,KAAK,QAAQ,GAAG,IAAI,KAAK,OAAO,MAAM,IAAI;AACjD,UAAM,iBAAiB,KAAK,cAAc;MAAI,CAAC,QAC9C,kBAAkB,aAAa,KAAK,IAAI;IACzC;AAEA,WAAO;MACN,SAAS,oBAAoB,GAAG;MAChC;MACA,UAAU;MACV;MACA,WAAW,KAAK;IACjB;EACD;EACA,QAAQ,CAAC,SAAS;AACjB,WAAO;MACN,QAAQ,CAAC,KAAK,SAAS,KAAK,QAAQ,KAAK,QAAQ,EAAE;QAClD;MACD;MACA,WAAW,KAAK;MAChB,eAAe,KAAK,eAAe,IAAI,kBAAkB,WAAW;IACrE;EACD;AACD,CAAC;AAEF,IAAM,cAAc;EACnB,IAAI,KAAK,eAAe;;;;;;IAMvB,UAAU;;;;IAIV,iBAAiB,IAAI,OAAO,mBAAmB;MAC9C,SAAS,IAAI,OAAO,QAAQ;MAC5B,SAAS;IACV,CAAC;;;;IAID,YAAY,IAAI,OAAO,cAAc,EAAE,MAAM,UAAU,SAAS,IAAI,OAAO,QAAQ,EAAE,CAAC;;;;IAItF,YAAY,IAAI,OAAO,cAAc,EAAE,aAAa,UAAU,SAAS,IAAI,OAAO,QAAQ,EAAE,CAAC;;;;IAI7F,SAAS,IAAI,OAAO,WAAW;MAC9B,SAAS,IAAI,OAAO,IAAI,OAAO,IAAI,GAAG,CAAC,CAAC;MACxC,cAAc,IAAI,OAAO,OAAO;IACjC,CAAC;;;;;;IAMD,aAAa,IAAI,OAAO,eAAe;MACtC,MAAM,WAAW,OAAO;MACxB,SAAS,IAAI,OAAO,QAAQ;IAC7B,CAAC;;IAED,SAAS,IAAI,OAAO,WAAW;MAC9B,SAAS,IAAI,OAAO,IAAI,OAAO,IAAI,GAAG,CAAC,CAAC;MACxC,cAAc,IAAI,OAAO,OAAO;MAChC,WAAW;MACX,QAAQ;IACT,CAAC;EACF,CAAC;AACF;AAEA,IAAM,0BAA0B,IAAI,OAAO,2BAA2B;EACrE,QAAQ,IAAI,OAAO,OAAO;EAC1B,cAAc,IAAI,OAAO,WAAW;AACrC,CAAC;AAED,IAAM,kBAAkB,IAAI,KAAK,mBAAmB;EACnD;EACA,aAAa;EACb,SAAS;EACT,yBAAyB;AAC1B,CAAC;AAED,IAAM,wBAAwB,IAAI,KAAK,yBAAyB;EAC/D,MAAM;EACN,OAAO,WAAW;AACnB,CAAC;AAED,IAAM,YAAY,IAAI,OAAO,aAAa;EACzC,SAAS;EACT,QAAQ,IAAI,OAAO;EACnB,MAAM,IAAI,OAAO;EACjB,YAAY,IAAI,OAAO,OAAO;AAC/B,CAAC;AAED,IAAM,UAAU,IAAI,OAAO,WAAW;EACrC,SAAS,IAAI,OAAO,YAAY;EAChC,OAAO;EACP,OAAO,IAAI,IAAI;EACf,QAAQ,IAAI,IAAI;AACjB,CAAC;AAED,IAAM,oBAAoB,IAAI,OAAO,qBAAqB;EACzD,MAAM;EACN,QAAQ;EACR,SAAS;EACT,YAAY;AACb,CAAC;AAED,IAAM,kBAAkB,IAAI,KAAK,mBAAmB;EACnD,IAAI;AACL,CAAC;AAED,IAAM,cAAc,IAAI,KAAK,eAAe;EAC3C,iBAAiB;EACjB,oBAAoB;EACpB,mBAAmB;EACnB,iBAAiB;AAClB,CAAC;AAED,IAAM,gBAAgB,IAAI,KAAK,iBAAiB;EAC/C,IAAI;AACL,CAAC;AAED,IAAM,QAAQ,IAAI,KAAK,SAAS;EAC/B,KAAK;AACN,CAAC;AAED,IAAM,SAAS,IAAI,OAAO,UAAU;EACnC,OAAO;EACP,SAAS;EACT,OAAO;AACR,CAAC;AAED,IAAM,gBAAgB,IAAI;EAAQ,CAAC,GAAG;EAAG,CAAC,MACzC,IAAI,OAAO,oBAAoB;IAC9B,QAAQ;IACR,OAAO;EACR,CAAC;AACF;AAEA,IAAM,sBAAsB,IAAI,KAAK,uBAAuB;EAC3D,SAAS,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACpC,WAAW,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACtC,WAAW,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACtC,SAAS,IAAI,OAAO,IAAI,GAAG,CAAC;AAC7B,CAAC;AAED,IAAM,YAAY,IAAI,KAAK,aAAa;EACvC,SAAS,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACpC,WAAW,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACtC,WAAW,IAAI,WAAW,IAAI,IAAI,GAAG,CAAC;EACtC,SAAS,IAAI,OAAO,IAAI,GAAG,CAAC;AAC7B,CAAC;AAED,IAAM,gBAAgB,IAAI,OAAO,iBAAiB;EACjD,QAAQ;EACR,QAAQ,IAAI,GAAG;AAChB,CAAC;AAED,IAAM,oBAAoB,IAAI,OAAO,qBAAqB;EACzD,QAAQ,IAAI,OAAO,aAAa;EAChC,WAAW,IAAI,IAAI;AACpB,CAAC;AAED,IAAM,WAAW,IAAI,OAAO,YAAY;EACvC,MAAM,IAAI,OAAO,mBAAmB;EACpC,QAAQ,IAAI,IAAI;EAChB,aAAa;AACd,CAAC;AAED,IAAM,eAAe,IAAI,OAAO,IAAI,GAAG,CAAC,EAAE,UAAU;EACnD,OAAO,CAAC,QAA8B,OAAO,QAAQ,WAAW,QAAQ,GAAG,IAAI;EAC/E,QAAQ,CAAC,QAAQ,MAAM,IAAI,WAAW,GAAG,CAAC;AAC3C,CAAC;AAED,IAAM,0BAA0B,IAAI,OAAO,2BAA2B;EACrE,eAAe,cAAc,eAAe;EAC5C,cAAc,IAAI,OAAO,YAAY;AACtC,CAAC;AAED,IAAM,mBAAmB,IAAI,OAAO,yBAAyB;EAC5D,MAAM;AACP,CAAC;AAED,IAAM,SAAS;EACd,GAAG;EACH,IAAI,IAAI,GAAG;EACX,KAAK,IAAI,IAAI;EACb,KAAK,IAAI,IAAI;EACb,KAAK,IAAI,IAAI;EACb,MAAM,IAAI,KAAK;EACf,MAAM,IAAI,KAAK;EACf,SAAS,IAAI,QAAQ;EACrB,MAAM,IAAI,KAAK;EACf,QAAQ,IAAI,OAAO;EACnB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA,KAAK,YAAY,IAAI,KAAK,WAAW;EACrC,IAAI,YAAY,GAAG,KAAK,WAAW;EACnC,kBAAkB,YAAY,iBAAiB,KAAK,WAAW;EAC/D,SAAS,YAAY,QAAQ,KAAK,WAAW;EAC7C,eAAe,YAAY,cAAc,KAAK,WAAW;EACzD,qBAAqB,YAAY,oBAAoB,KAAK,WAAW;EACrE,eAAe,YAAY,cAAc,KAAK,WAAW;EACzD,iBAAiB,YAAY,gBAAgB,KAAK,WAAW;EAC7D,kBAAkB,YAAY,iBAAiB,KAAK,WAAW;EAC/D,oBAAoB,YAAY,mBAAmB,KAAK,WAAW;EACnE,cAAc,YAAY,aAAa,KAAK,WAAW;EACvD,OAAO,YAAY;AACpB;AAEA,YAAY,gBAAgB,cAAc,MAAM,IAAI,OAAO,EAAE,MAAM,aAAa,CAAC,CAAC;AAClF,YAAY,gBAAgB,cAAc,MAAM,WAAW,CAAC;AAC5D,YAAY,gBAAgB,YAAY,CAAC,MAAM,SAAS,CAAC,CAAC;AAE1D;EACC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACD,EAAE,QAAQ,CAAC,SAAS;AACnB,cAAY,gBAAgB,KAAK,MAAM,MAAM,IAAI;AAClD,CAAC;;;ACrgBM,IAAMC,gBAAe,OAAO;;EAElC,QAAQ,OAAO;;EAEf,UAAU,OAAO;;EAEjB,SAAS,MAAM,CAAC,OAAO,GAAG,OAAO,GAAG,OAAO,CAAC,CAAC;AAC9C,CAAC;AAGD,IAAMC,aAAY,MAAM;EACvB,OAAO,EAAE,YAAYD,cAAa,CAAC;EACnC,OAAO;IACN,QAAQ,OAAO;MACd,UAAU,OAAO;MACjB,sBAAsB,MAAM,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC;MACjD,SAAS,QAAQ;IAClB,CAAC;EACF,CAAC;EACD,OAAO,EAAE,WAAWA,cAAa,CAAC;AACnC,CAAC;AAEM,IAAM,cAAc,OAAO,EAAE,MAAM,MAAM,QAAQ,CAAC,EAAE,CAAC;AACrD,IAAM,gBAAgB,OAAO,EAAE,QAAQC,WAAU,CAAC;AAIlD,IAAM,iBAAiB,MAAM,CAAC,aAAa,aAAa,CAAC;AAMhE,SAAS,KAAK,MAAe,MAA4B;AACxD,SAAO;IACN,MAAM,MAAM;MACX,gBAAgB,aACb,OACA,gBAAgB,IAAI,IACpB,KAAK,QAAQ;;QAEb,OAAI,IAAI,MAAO,MAAM,EAAE,SAAS,SAAS,CAAC,EAAE,QAAQ;;IACxD;EACD;AACD;AAEO,IAAM,SAAS;EACrB;EACA,UAAU,EAAE,UAAU,QAAQ,QAAQ,GAAgC;AACrE,WAAO;MACN,QAAQ;QACP,YAAY;UACX;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;EACA,gBAAgB,EAAE,UAAU,SAAS,qBAAqB,GAAmC;AAC5F,WAAO;MACN,QAAQ;QACP,QAAQ;UACP;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;EACA,aAAa,EAAE,UAAU,QAAQ,QAAQ,GAAgC;AACxE,WAAO;MACN,QAAQ;QACP,WAAW;UACV;UACA;UACA,UAAU,oBAAoB,QAAQ;QACvC;MACD;IACD;EACD;AACD;AAEO,SAAS,iBAAiB,KAA6B;AAC7D,MAAI,OAAO,QAAQ,UAAU;AAC5B,WAAO,oBAAoB,GAAG;EAC/B;AACA,MAAI,gBAAgB,IAAI,QAAQ;AAC/B,WAAO,oBAAoB,IAAI,OAAO,WAAW,QAAQ;EAC1D;AAEA,MAAI,eAAe,IAAI,QAAQ;AAC9B,WAAO,oBAAoB,IAAI,OAAO,UAAU,QAAQ;EACzD;AAEA,SAAO,oBAAoB,IAAI,OAAO,OAAO,QAAQ;AACtD;AAEO,SAAS,qBAAqB,KAAkD;AACtF,SAAO,OAAO,QAAQ,YAAY,YAAY,OAAO,YAAY,IAAI,SAClE,IAAI,OAAO,SACX;AACJ;AAMO,SAAS,2BAA2B,KAA8B;AApHzE;AAqHC,WAAO,0BAAqB,GAAG,MAAxB,mBAA2B,YAAW;AAC9C;;;AC9FA,IAAM,SAAS,CAA6B,SAC3C,MAAM,CAAC,OAAO,EAAE,MAAM,MAAM,CAAC,QAAQ,IAAI,GAAG,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC;AAEjF,IAAM,wBAAwB,MAAM;EAC1C,OAAO;IACN,MAAM,QAAQ,OAAO;IACrB,OAAO,QAAQ;IACf,OAAO,SAAS,IAAI,CAAC;IACrB,MAAM,SAAS,QAAQ,QAAQ,CAAC;EACjC,CAAC;EACD,OAAO;IACN,MAAM,QAAQ,OAAO;IACrB,OAAO,QAAQ;IACf,OAAO,SAAS,IAAI,CAAC;IACrB,MAAM,QAAQ,MAAM;EACrB,CAAC;AACF,CAAC;AAGD,IAAM,2BAA2B;EAChC;EACA,OAAO,EAAE,MAAM,QAAQ,SAAS,EAAE,CAAC;EACnC,OAAO,EAAE,MAAM,QAAQ,QAAQ,GAAG,OAAO,QAAQ,EAAE,CAAC;EACpD,OAAO;IACN,MAAM,QAAQ,cAAc;IAC5B,OAAO,QAAQ;IACf,aAAa,QAAQ;EACtB,CAAC;AACF;AAGO,IAAM,sBAAsB,MAAM,CAAC,GAAG,wBAAwB,CAAC;AAG/D,IAAM,sBAAsB,OAAO;EACzC,MAAM,QAAQ,UAAU;EACxB,QAAQ,OAA0C,UAAU,OAAO,EAAE,SAAS;EAC9E,eAAe,MAAM,OAAO,CAAC;EAC7B,WAAW,MAAM,mBAAmB;AACrC,CAAC;AAGM,IAAM,6BAA6B,OAAO;EAChD,MAAM,QAAQ,iBAAiB;EAC/B,SAAS,MAAM,mBAAmB;EAClC,SAAS;AACV,CAAC;AAGM,IAAM,wBAAwB,OAAO;EAC3C,MAAM,QAAQ,YAAY;EAC1B,MAAM;EACN,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAGM,IAAM,wBAAwB,OAAO;EAC3C,MAAM,QAAQ,YAAY;EAC1B,aAAa;EACb,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAGM,IAAM,yBAAyB,OAAO;EAC5C,MAAM,QAAQ,aAAa;;;;EAI3B,MAAM,SAAS,OAAO,OAAO,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC;EAGlD,SAAS,MAAM,mBAAmB;AACnC,CAAC;AAGM,IAAM,qBAAqB,OAAO;EACxC,MAAM,QAAQ,SAAS;EACvB,SAAS,MAAM,MAAM,QAAQ,CAAC,CAAC;EAC/B,cAAc,MAAM,OAAO,CAAC;AAC7B,CAAC;AAKM,IAAK,iBAAL,CAAKC,mBAAL;AACNA,iBAAAA,eAAA,YAAA,IAAa,CAAA,IAAb;AACAA,iBAAAA,eAAA,UAAA,IAAW,GAAA,IAAX;AACAA,iBAAAA,eAAA,UAAA,IAAW,GAAA,IAAX;AAHW,SAAAA;AAAA,GAAA,iBAAA,CAAA,CAAA;AAML,IAAM,qBAAqB,OAAO;EACxC,MAAM,QAAQ,SAAS;EACvB,SAAS,MAAM,MAAM,QAAQ,CAAC,CAAC;EAC/B,cAAc,MAAM,OAAO,CAAC;EAC5B,WAAW,OAAO;EAClB,QAAQ;AACT,CAAC;AAGD,IAAM,mBAAmB;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;AACD;AAEO,IAAM,kBAAkB,MAAM,CAAC,GAAG,gBAAgB,CAAC;AAWnD,IAAM,eAAe;EAC3B,SACC,OAIsB;AACtB,WAAOC;MACN;QACC,MAAM;QACN,QAAQ,MAAM;QACd,WAAW,MAAM,aAAa,CAAC;QAC/B,eAAe,MAAM,iBAAiB,CAAC;MACxC;MACA;IACD;EACD;EACA,gBACC,SACA,SAC6B;AAC7B,QAAI,QAAQ,SAAS,WAAW,QAAQ,SAAS,UAAU,OAAO,QAAQ,UAAU,UAAU;AAC7F,cAAQ,QAAQ,OAAO,KAAK,OAAI,QAAQ,UAAU,QAAQ,KAAK,CAAC;IACjE;AAEA,WAAOA,QAAO,EAAE,MAAM,mBAAmB,SAAS,QAAQ,GAAG,0BAA0B;EACxF;EACA,WAAW,MAA2B,SAAuD;AAE5F,YAAQ,QAAQ,CAAC,UAAU;AAC1B,UAAI,MAAM,SAAS,WAAW,MAAM,SAAS,UAAU,OAAO,MAAM,UAAU,UAAU;AACvF,cAAM,QAAQ,OAAO,KAAK,OAAI,IAAI,UAAU,MAAM,KAAK,CAAC;MACzD;IACD,CAAC;AAED,WAAOA;MACN;QACC,MAAM;QACN;QACA;MACD;MACA;IACD;EACD;EACA,WACC,aACA,SACwB;AACxB,WAAOA,QAAO,EAAE,MAAM,cAAc,aAAa,QAAQ,GAAG,qBAAqB;EAClF;EACA,QAAQ;IACP;IACA;EACD,GAGuB;AACtB,WAAOA;MACN;QACC,MAAM;QACN,SAAS,QAAQ;UAAI,CAAC,WACrB,OAAO,WAAW,WAAW,MAAM,KAAK,QAAQ,MAAM,CAAC,IAAI;QAC5D;QACA,cAAc,aAAa,IAAI,CAAC,QAAQ,qBAAqB,GAAG,CAAC;MAClE;MACA;IACD;EACD;EACA,QAAQ;IACP;IACA;IACA;IACA;EACD,GAKuB;AACtB,WAAOA;MACN;QACC,MAAM;QACN,SAAS,QAAQ;UAAI,CAAC,WACrB,OAAO,WAAW,WAAW,MAAM,KAAK,QAAQ,MAAM,CAAC,IAAI;QAC5D;QACA,cAAc,aAAa,IAAI,CAAC,QAAQ,qBAAqB,GAAG,CAAC;QACjE;QACA;MACD;MACA;IACD;EACD;EACA,YAAY;IACX;IACA;EACD,GAE2B;AAC1B,WAAOA;MACN;QACC,MAAM;QACN,MAAM,OAAO,EAAE,MAAM,kBAAkB,aAAa,IAAI,EAAE,IAAI,EAAE,MAAM,KAAK;QAC3E;MACD;MACA;IACD;EACD;AACD;;;ACvPO,SAAS,WACf,UACC;AA2BD,WAAS,KAAK,OAAgB,MAAsC;AACnE,WAAO,SAAS,OAAO,IAAI;EAC5B;AAEA,OAAK,KAAK,CAAC,UAAkB,SAAS,OAAI,GAAG,UAAU,KAAK,CAAC;AAC7D,OAAK,MAAM,CAAC,UAAkB,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAkB,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AAC/D,OAAK,MAAM,CAAC,UAAoC,SAAS,OAAI,IAAI,UAAU,KAAK,CAAC;AACjF,OAAK,OAAO,CAAC,UAAoC,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAoC,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AACnF,OAAK,OAAO,CAAC,UAAmB,SAAS,OAAI,KAAK,UAAU,KAAK,CAAC;AAClE,OAAK,SAAS,CAAC,UAAkB,SAAS,OAAI,OAAO,UAAU,KAAK,CAAC;AACrE,OAAK,UAAU,CAAC,UAAkB,SAAS,OAAI,QAAQ,UAAU,KAAK,CAAC;AACvE,OAAK,KAAK,KAAK;AAEf,SAAO;AACR;;;AC1CO,SAAS,cAAc,SAAiB,MAA8B;AAC5E,QAAM,eAAe,MAAM,KAAK,GAAG,OAAA,IAAW,EAAE,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAE1E,QAAM,cAAc,IAAI,WAAW,aAAa,SAAS,KAAK,MAAM;AACpE,cAAY,IAAI,YAAY;AAC5B,cAAY,IAAI,MAAM,aAAa,MAAM;AAEzC,SAAO,QAAQ,aAAa,EAAE,OAAO,GAAG,CAAC;AAC1C;;;ACOO,IAAMC,yBAAwB;EACpC;IACC,MAAM,CAAC,OAAO,EAAE,OAAO,QAAQ,EAAE,CAAC,GAAG,OAAO,EAAE,MAAM,MAAM,CAAC,QAAQ,IAAI,GAAG,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC9F;AACD;AAGA,IAAM,sBAAsB,OAAiC,uBAAuB,CAAC,QAAQ;AAC5F,MAAI,CAAC,CAAC,UAAU,UAAU,QAAQ,EAAE,SAAS,OAAO,GAAG;AAAG,WAAO;AAEjE,MAAI;AACH,WAAO,GAAa;AACpB,WAAO;EACR,QAAE;AACD,WAAO;EACR;AACD,CAAC;AAED,IAAM,YAAY,OAAO;EACxB,QAAQ,SAAS,mBAAmB;EACpC,OAAO,SAAS,mBAAmB;EACnC,SAAS,SAAS,MAAMC,aAAY,CAAC;EACrC,OAAO,SAAS,OAAO,CAAC;AACzB,CAAC;AAGM,IAAM,mCAAmC,OAAO;EACtD,SAAS,QAAQ,CAAC;EAClB,QAAQ,SAAS,OAAO,CAAC;EACzB,YAAYD;EACZ,WAAW;EACX,QAAQ,MAAM,qBAAqB;EACnC,cAAc,MAAM,eAAe;AACpC,CAAC;AAGD,SAAS,kBAAkB,SAAiB;AAC3C,SAAO,oBAAoB,OAAO,EAAE,QAAQ,MAAM,EAAE;AACrD;AAEO,IAAM,8BAAN,MAAM,6BAA4B;EA0FxC,YAAY,OAA0C;AAPtD,SAAA,UAAU;AAQT,SAAK,SAAS,+BAAO;AACrB,SAAK,aAAa,+BAAO;AACzB,SAAK,aAAY,+BAAO,cAAa,CAAC;AACtC,SAAK,UAAS,+BAAO,WAAU,CAAC;AAChC,SAAK,gBAAe,+BAAO,iBAAgB,CAAC;EAC7C;EA/FA,OAAO,cAAc,OAAmB;AACvC,UAAM,OAAO,OAAI,gBAAgB,MAAM,KAAK;AAC5C,UAAM,iBAAiB,6BAA6B,OAAO,KAAK,0BAA0B;AAC1F,QAAI,CAAC,gBAAgB;AACpB,YAAM,IAAI,MAAM,mCAAmC;IACpD;AAEA,UAAM,aAAaE;MAClB;QACC,SAAS;QACT,WAAW,CAAC;QACZ,QAAQ,eAAe,OAAO;UAAI,CAAC,OAAgB,UAClDA;YACC;cACC,MAAM;cACN;cACA;cACA,MAAM,GAAG,OAAO,WAAW,IAAI,SAAS;YACzC;YACA;UACD;QACD;QACA,cAAc,eAAe;MAC9B;MACA;IACD;AAEA,WAAO,6BAA4B,QAAQ,UAAU;EACtD;EAEA,OAAO,UAAU,OAAmB;AA9FrC;AA+FE,UAAM,UAAU,OAAI,gBAAgB,MAAM,KAAK;AAC/C,UAAM,OAAO,mCAAS;AACtB,UAAM,iBACL,6BAA6B,KAAK,QAAO,kCAAM,SAAN,mBAAY,0BAA0B;AAChF,QAAI,CAAC,QAAQ,CAAC,gBAAgB;AAC7B,YAAM,IAAI,MAAM,mCAAmC;IACpD;AAEA,UAAM,aAAaA;MAClB;QACC,SAAS;QACT,QAAQ,KAAK;QACb,YAAY,KAAK;QACjB,WAAW,KAAK;QAChB,QAAQ,eAAe,OAAO;UAAI,CAAC,OAAgB,UAClDA;YACC;cACC,MAAM;cACN;cACA;cACA,MAAM,GAAG,OAAO,WAAW,IAAI,SAAS;YACzC;YACA;UACD;QACD;QACA,cAAc,eAAe;MAC9B;MACA;IACD;AAEA,WAAO,6BAA4B,QAAQ,UAAU;EACtD;EAEA,OAAO,QAAQ,MAAwC;AACtD,WAAO,MAAM,gCAAgC;AAC7C,UAAM,kBAAkB,IAAI,6BAA4B;AACxD,WAAO,OAAO,iBAAiB,IAAI;AACnC,WAAO;EACR;;;;;;;EAQA,OAAO,mBAAmB,OAAmB;AAC5C,UAAM,OAAO,cAAc,mBAAmB,KAAK;AACnD,WAAO,MAAM,IAAI;EAClB;EAiBA,MAAM;IACL,eAAe;IACf;IACA;EACD,IAII,CAAC,GAAG;AAEP,UAAM,SAAS,KAAK,OAAO,IAAI,CAAC,UAAU;AACzC,aAAO,MAAM,OAAO,cAAc;AAClC,aAAO,MAAM;IACd,CAAC;AAED,UAAM,OAAO;MACZ,yBAAyB;QACxB;QACA,cAAc,KAAK;MACpB;IACD;AAEA,QAAI,qBAAqB;AACxB,aAAO,OAAI,gBAAgB,UAAU,MAAM,EAAE,SAAS,aAAa,CAAC,EAAE,QAAQ;IAC/E;AAEA,UAAM,cAAa,uCAAW,eAAc,KAAK;AACjD,UAAM,UAAS,uCAAW,WAAU,KAAK;AACzC,UAAM,YAAY,EAAE,GAAG,KAAK,WAAW,GAAG,uCAAW,UAAU;AAE/D,QAAI,CAAC,QAAQ;AACZ,YAAM,IAAI,MAAM,4BAA4B;IAC7C;AAEA,QAAI,CAAC,UAAU,QAAQ;AACtB,YAAM,IAAI,MAAM,oBAAoB;IACrC;AAEA,QAAI,CAAC,UAAU,SAAS;AACvB,YAAM,IAAI,MAAM,qBAAqB;IACtC;AAEA,QAAI,CAAC,UAAU,OAAO;AACrB,YAAM,IAAI,MAAM,mBAAmB;IACpC;AAEA,UAAM,kBAAkB;MACvB,QAAQ,kBAAkB,MAAM;MAChC,YAAY,aAAa,aAAa,EAAE,MAAM,KAAK;MACnD,SAAS;QACR,SAAS,UAAU;QACnB,OAAO,kBAAkB,KAAK,UAAU,SAAS,MAAM;QACvD,OAAO,OAAO,UAAU,KAAK;QAC7B,QAAQ,OAAO,UAAU,MAAM;MAChC;MACA,MAAM;QACL,yBAAyB;UACxB;UACA,cAAc,KAAK;QACpB;MACD;IACD;AAEA,WAAO,OAAI,gBAAgB;MAC1B,EAAE,IAAI,gBAAgB;MACtB,EAAE,SAAS,aAAa;IACzB,EAAE,QAAQ;EACX;EAEA,YAAY;AACX,UAAM,QAAQ,KAAK,MAAM,EAAE,qBAAqB,MAAM,CAAC;AACvD,WAAO,6BAA4B,mBAAmB,KAAK;EAC5D;EAEA,WAA6C;AAC5C,WAAOA,QAAO,MAAM,gCAAgC;EACrD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;ACjPA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAAA,IAAA;AAqCA,IAAM,uBAAuB;EAC5B,qBAAqB,KAAK;EAC1B,UAAU;EACV,eAAe;EACf,gBAAgB,MAAM;AACvB;AAEA,SAAS,wBAAwB,OAAkC;AAClE,QAAM,aAAkC,EAAE,MAAM,UAAU,MAAM;AAEhE,QAAM,gBAAuC,CAAC;AAC9C,QAAM,kBAAkB,CAAC,gBACvB,cAAA,WAAA,MAAA,cAAA,WAAA,IAA+B;IAC/B,MAAM;IACN;IACA;EACD;AAED,SAAO,IAAI,MAAM,YAAY;IAC5B,MAAM;AACL,YAAM,IAAI;QACT;MACD;IACD;;;;IAIA,IAAI,QAAQ,UAAU;AAErB,UAAI,YAAY,QAAQ;AACvB,eAAO,QAAQ,IAAI,QAAQ,QAAQ;MACpC;AAGA,UAAI,aAAa,OAAO,UAAU;AACjC,eAAO,aAAa;AACnB,cAAI,IAAI;AACR,iBAAO,MAAM;AACZ,kBAAM,gBAAgB,CAAC;AACvB;UACD;QACD;MACD;AAEA,UAAI,OAAO,aAAa;AAAU;AAElC,YAAM,cAAc,SAAS,UAAU,EAAE;AACzC,UAAI,OAAO,MAAM,WAAW,KAAK,cAAc;AAAG;AAClD,aAAO,gBAAgB,WAAW;IACnC;EACD,CAAC;AACF;AAEA,SAAS,gBAAgB,gBAAgD;AACxE,QAAM,MAAM,iBAAiB,cAAc;AAC3C,MAAI,KAAK;AACR,WACC,IAAI,OAAO,YAAY,SACvB,IAAI,OAAO,WAAW,cACtB,IAAI,OAAO,SAAS;EAEtB;AACA,SAAO;AACR;AAEA,SAAS,aAAa,SAAkC;AACvD,MAAI,CAAC,QAAQ,QAAQ;AACpB,UAAM,IAAI;MACT;IACD;EACD;AAEA,SAAO,QAAQ;AAChB;AAEA,IAAM,oBAAoB,OAAO,IAAI,qBAAqB;AAE1D,IAAM,SAAS;;EAEd,UAAU;;EAEV,eAAe;;EAEf,gBAAgB;;EAEhB,qBAAqB;AACtB;AAKA,IAAM,oBAAoB;AAG1B,IAAM,wBAAwB;AAE9B,IAAM,QAAQ,CAAI,KAAU,SAC3B,MAAM;EAAK,EAAE,QAAQ,KAAK,KAAK,IAAI,SAAS,IAAI,EAAE;EAAG,CAAC,GAAG,MACxD,IAAI,MAAM,IAAI,MAAM,IAAI,OAAO,IAAI;AACpC;AAeM,SAAS,mBAAmB,KAAuC;AACzE,SAAO,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAa,IAAY,iBAAiB,MAAM;AAChF;AAOO,IAAM,oBAAN,MAAuB;EAsG7B,YAAY,aAAgC;AAoB5C,IAAAC,cAAA,MAAA,MAAA;AA8EA,IAAAA,cAAA,MAAA,6BAAA;AA+HA,IAAAA,cAAA,MAAA,UAAA;AAqDA,IAAAA,cAAA,MAAA,SAAA;AAeA,IAAAA,cAAA,MAAM,kBAAA;AAmDN,IAAAA,cAAA,MAAM,gBAAA;AAQN,IAAAA,cAAA,MAAM,oBAAA;AAqMN,IAAAA,cAAA,MAAM,QAAA;AA3kBN,IAAAA,cAAA,MAAA,YAAA,MAAA;AAuCC,IAAAC,cAAA,MAAK,YAAa,IAAI;MACrB,cAAc,YAAY,YAAY;IACvC,CAAA;EACD;;;;;EArGA,OAAO,SAAS,YAAiC;AAChD,UAAM,KAAK,IAAI,kBAAiB;AAEhC,IAAAA,cAAA,IAAG,YAAa,4BAA4B;MAC3C,OAAO,eAAe,WAAW,QAAQ,UAAU,IAAI;IACxD,CAAA;AAEA,WAAO;EACR;;;;;;;EAQA,OAAO,KAAK,YAAiC;AAC5C,UAAM,KAAK,IAAI,kBAAiB;AAGhC,QAAI,OAAO,eAAe,YAAY,CAAC,WAAW,WAAW,GAAG,GAAG;AAClE,MAAAA,cAAA,IAAG,YAAa,4BAA4B;QAC3C,OAAO,eAAe,WAAW,QAAQ,UAAU,IAAI;MACxD,CAAA;IACD,OAAO;AACN,MAAAA,cAAA,IAAG,YAAa,4BAA4B,QAAQ,KAAK,MAAM,UAAU,CAAC,CAAA;IAC3E;AAEA,WAAO;EACR;EAEA,UAAU,QAAgB;AACzB,IAAAC,cAAA,MAAK,UAAA,EAAW,SAAS;EAC1B;;;;;EAKA,kBAAkB,QAAgB;AACjC,QAAI,CAACA,cAAA,MAAK,UAAA,EAAW,QAAQ;AAC5B,MAAAA,cAAA,MAAK,UAAA,EAAW,SAAS;IAC1B;EACD;EACA,cAAc,YAAoC;AACjD,IAAAA,cAAA,MAAK,UAAA,EAAW,aAAa;EAC9B;EACA,YAAY,OAAwB;AACnC,IAAAA,cAAA,MAAK,UAAA,EAAW,UAAU,QAAQ,OAAO,KAAK;EAC/C;EACA,aAAa,QAAyB;AACrC,IAAAA,cAAA,MAAK,UAAA,EAAW,UAAU,SAAS,OAAO,MAAM;EACjD;EACA,YAAY,OAAe;AAC1B,IAAAA,cAAA,MAAK,UAAA,EAAW,UAAU,QAAQ;EACnC;EACA,cAAc,UAA0B;AACvC,IAAAA,cAAA,MAAK,UAAA,EAAW,UAAU,UAAU,SAAS,IAAI,CAAC,YAAY,KAAK,SAASC,aAAY,CAAC;EAC1F;;EAIA,IAAI,YAAY;AACf,WAAOD,cAAA,MAAK,UAAA,EAAW,SAAS;EACjC;;;EAIA,KAAK,iBAAiB,IAAI;AACzB,WAAO;EACR;;EAGA,IAAI,OAAsC;AACzC,WAAO,eAAe,MAAM,QAAQ;MACnC,YAAY;MACZ,OAAO,WAAW,CAAC,OAAO,SAAS;AAClC,YAAI,gBAAgB,KAAK,GAAG;AAC3B,iBAAO,gBAAA,MAAK,QAAA,QAAA,EAAL,KAAA,MAAY,QAAQ;YAC1B,MAAM,MAAM,KAAK,MAAM,QAAQ,CAAC;UACjC,CAAA;QACD;AAGA,eAAO,gBAAA,MAAK,QAAA,QAAA,EAAL,KAAA,MACN,QACA,iBAAiB,aACd,OAAO,KAAK,KAAK,IACjB,OACA,OAAO,KAAK,OAAO,IAAI,IACvB,KAAA;MAEL,CAAC;IACF,CAAC;AAED,WAAO,KAAK;EACb;;EASA,IAAI,MAAiC;AACpC,WAAO,EAAE,MAAM,UAAU;EAC1B;;;;EA8BA,OAAO,OAA+B;AACrC,QAAI,OAAO,UAAU,YAAY,UAAU,OAAO;AACjD,aAAO;IACR;AAEA,UAAM,KAAK,iBAAiB,KAAK;AAEjC,UAAM,WAAWA,cAAA,MAAK,UAAA,EAAW,OAAO;MACvC,CAAC,MAAM,EAAE,SAAS,YAAY,OAAO,iBAAiB,EAAE,KAAK;IAC9D;AAGA,QACC,YACA,GAAG,SAAS,OAAO,aAAa,KAChC,YAAY,SAAS,MAAM,UAC3B,GAAG,OAAO,aAAa,KACvB,YAAY,MAAM,QACjB;AACD,eAAS,MAAM,OAAO,OAAO,UAC5B,SAAS,MAAM,OAAO,OAAO,WAAW,MAAM,OAAO,OAAO;IAC9D;AAEA,WACC,YACA,gBAAA,MAAK,QAAA,QAAA,EAAL,KAAA,MAAY,UAAU,OAAO,UAAU,WAAW,oBAAoB,KAAK,IAAI,KAAA;EAEjF;;;;;EAMA,aAAa,MAAgD;AAC5D,WAAO,KAAK,OAAO,OAAO,UAAU,GAAG,IAAI,CAAC;EAC7C;;;;;EAMA,gBAAgB,MAAmD;AAClE,WAAO,KAAK,OAAO,OAAO,aAAa,GAAG,IAAI,CAAC;EAChD;;;;;EAMA,mBAAmB,MAAsD;AACxE,WAAO,KAAK,OAAO,OAAO,gBAAgB,GAAG,IAAI,CAAC;EACnD;;EAGA,IAAI,aAA8B;AACjC,UAAM,QAAQA,cAAA,MAAK,UAAA,EAAW,aAAa,KAAK,WAAW;AAC3D,WAAO,wBAAwB,QAAQ,CAAC;EACzC;;EAcA,WACC,MACA,SACC;AACD,WAAO,KAAK;MACX,aAAa;QACZ,OAAO,SAAS,WAAW,KAAK,OAAO,IAAI,IAAI;QAC/C,QAAQ;UAAI,CAAC,WACZ,OAAO,WAAW,YAAY,OAAO,WAAW,YAAY,OAAO,WAAW,WAC3E,KAAK,KAAK,IAAI,MAAM,IACpB,gBAAA,MAAK,+BAAA,+BAAA,EAAL,KAAA,MAAmC,MAAA;QACvC;MACD;IACD;EACD;EACA,WACC,aACA,SACC;AACD,WAAO,KAAK;MACX,aAAa;QACZ,OAAO,gBAAgB,WAAW,KAAK,OAAO,WAAW,IAAI;QAC7D,QAAQ,IAAI,CAAC,QAAS,OAAO,QAAQ,WAAW,KAAK,OAAO,GAAG,IAAI,GAAI;MACxE;IACD;EACD;EACA,QAAQ,EAAE,SAAS,aAAa,GAA+D;AAC9F,WAAO,KAAK;MACX,aAAa,QAAQ;QACpB;QACA;MACD,CAAC;IACF;EACD;EACA,QAAQ;IACP;IACA;IACA;IACA;EACD,GAKG;AACF,WAAO,KAAK;MACX,aAAa,QAAQ;QACpB;QACA;QACA;QACA,QAAQ,OAAO,WAAW,WAAW,KAAK,OAAO,MAAM,IAAI;MAC5D,CAAC;IACF;EACD;EACA,SAAS;IACR,WAAW;IACX;IACA;EACD,GAIG;AACF,WAAO,KAAK;MACX,aAAa,SAAS;QACrB,WAAW,6BAAM,IAAI,CAAC,QAAQ,gBAAA,MAAK,+BAAA,+BAAA,EAAL,KAAA,MAAmC,GAAA;QACjE;QACA;MACD,CAAC;IACF;EACD;EACA,gBACC,SACA,SACC;AACD,WAAO,KAAK;MACX,aAAa;QACZ,QAAQ,IAAI,CAAC,QAAS,OAAO,QAAQ,WAAW,KAAK,OAAO,GAAG,IAAI,GAAI;QACvE,OAAO,YAAY,WAChB,KAAK,KAAK,QAAQ,OAAO,IACzB,gBAAA,MAAK,+BAAA,+BAAA,EAAL,KAAA,MAAmC,OAAA;MACvC;IACD;EACD;EACA,YAAY;IACX;IACA;EACD,GAGG;AACF,WAAO,KAAK;MACX,aAAa,YAAY;QACxB;QACA,SAAS,QAAQ,IAAI,CAAC,QAAS,OAAO,QAAQ,WAAW,KAAK,OAAO,GAAG,IAAI,GAAI;MACjF,CAAC;IACF;EACD;;;;;;;;;;;;;EAcA,YAAY;AACX,WAAO,KAAK,UAAUA,cAAA,MAAK,UAAA,EAAW,SAAS,CAAC;EACjD;;EA8BA,MAAM,KAAK,SAAmD;AAC7D,UAAM,EAAE,QAAQ,GAAG,aAAa,IAAI;AACpC,UAAM,QAAQ,MAAM,KAAK,MAAM,YAAY;AAC3C,WAAO,OAAO,qBAAqB,KAAK;EACzC;;EAGA,MAAM,MAAM,UAAwB,CAAC,GAAwB;AAC5D,UAAM,gBAAA,MAAK,UAAA,UAAA,EAAL,KAAA,MAAc,OAAA;AACpB,WAAOA,cAAA,MAAK,UAAA,EAAW,MAAM;MAC5B,cAAc,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,kBAAkB,OAAA;MAChD,qBAAqB,QAAQ;IAC9B,CAAC;EACF;;EAGA,MAAM,UACL,UAEI,CAAC,GACa;AAClB,UAAM,gBAAA,MAAK,UAAA,UAAA,EAAL,KAAA,MAAc,OAAA;AACpB,WAAOA,cAAA,MAAK,UAAA,EAAW,UAAU;EAClC;AAsUD;AAhsBO,IAAM,mBAAN;AAgEN,aAAA,oBAAA,QAAA;AA0DA,SAAA,oBAAA,QAAA;AAAA,WAAmC,SAAC,MAAS,OAAiB;AAC7D,QAAM,QAAQA,cAAA,MAAK,UAAA,EAAW,OAAO;AACrC,QAAM,QAAQE;IACb;MACC,MAAM;;MAEN,OAAO,OAAO,UAAU,WAAW,OAAO,KAAK,IAAI;MACnD;MACA;IACD;IACA;EACD;AACA,EAAAF,cAAA,MAAK,UAAA,EAAW,OAAO,KAAK,KAAK;AACjC,SAAO;AACR;AAgEA,gCAAA,oBAAA,QAAA;AAAA,kCAA6B,SAC5B,KACsB;AACtB,MAAI,gBAAgB,GAAG,GAAG;AACzB,WAAO,KAAK,KAAK,GAAG;EACrB;AAEA,SAAO;AACR;AAuHA,aAAA,oBAAA,QAAA;AAAA,eAAU,SAAC,KAA0B,EAAE,gBAAgB,OAAO,GAAiB;AAE9E,MAAI,UAAU,OAAO,OAAO,GAAG,MAAM,UAAU;AAC9C,WAAO,OAAO,GAAG;EAClB;AAEA,MAAI,CAAC,gBAAgB;AACpB,WAAO,qBAAqB,GAAG;EAChC;AAGA,QAAM,YAAY,iDAAgB,WAAW,OAAO,GAAG;AACvD,MAAI,CAAC,WAAW;AACf,UAAM,IAAI,MAAM,sCAAsC,OAAO,GAAG,CAAA,GAAI;EACrE;AAEA,QAAM,QACL,SAAS,YAAY,UAAU,MAAM,SAAS,YAAY,UAAU,MAAM,UAAU;AAErF,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,gDAAgD,OAAO,GAAG,CAAA,GAAI;EAC/E;AAGA,SAAO,OAAO,KAAK;AACpB;AA4BA,YAAA,oBAAA,QAAA;AAAA,cAAS,SAAC,SAAuB;AAChC,QAAM,sBAAsB,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,uBAAuB,OAAA;AAEnE,EAAAA,cAAA,MAAK,UAAA,EAAW,OAAO,QAAQ,CAAC,OAAO,UAAU;AAChD,QAAI,GAAG,MAAM,OAAO,WAAW,GAAG;AACjC,UAAI,MAAM,MAAM,KAAK,SAAS,qBAAqB;AAClD,cAAM,IAAI;UACT,kBAAkB,KAAA,yCAA8C,mBAAA,eAAkC,MAAM,MAAM,KAAK,MAAA;QACpH;MACD;IACD;EACD,CAAC;AACF;AAGM,qBAAA,oBAAA,QAAA;AAAA,uBAAkB,eAAC,SAAuB;AAC/C,MAAIA,cAAA,MAAK,UAAA,EAAW,UAAU,SAAS;AACtC,UAAM,gBAAgB,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,iBAAiB,OAAA;AACvD,QAAIA,cAAA,MAAK,UAAA,EAAW,UAAU,QAAQ,SAAS,eAAe;AAC7D,YAAM,IAAI,MAAM,0CAA0C,aAAA,EAAe;IAC1E;EACD;AAGA,MAAI,QAAQ,uBAAuBA,cAAA,MAAK,UAAA,EAAW,UAAU,SAAS;AACrE;EACD;AAEA,QAAM,WAAWA,cAAA,MAAK,UAAA,EAAW,UAAU,SAASA,cAAA,MAAK,UAAA,EAAW;AAEpE,QAAM,QAAQ,MAAM,aAAa,OAAO,EAAE,SAAS;IAClD,OAAO;IACP,UAAU;EACX,CAAC;AAED,QAAM,eAAe,MAAM,KAEzB,OAAO,CAAC,SAAS;AACjB,UAAM,gBAAgBA,cAAA,MAAK,UAAA,EAAW,OAAO,KAAK,CAAC,UAAU;AAC5D,UACC,GAAG,MAAM,OAAO,cAAc,KAC9B,YAAY,MAAM,SAClB,gBAAgB,MAAM,MAAM,QAC3B;AACD,eAAO,KAAK,iBAAiB,MAAM,MAAM,OAAO,WAAW;MAC5D;AAEA,aAAO;IACR,CAAC;AAED,WAAO,CAAC;EACT,CAAC,EACA,MAAM,GAAG,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,iBAAiB,OAAA,IAAW,CAAC,EACtD,IAAI,CAAC,UAAU;IACf,UAAU,KAAK;IACf,QAAQ,KAAK;IACb,SAAS,KAAK;EACf,EAAE;AAEH,MAAI,CAAC,aAAa,QAAQ;AACzB,UAAM,IAAI,MAAM,+CAA+C;EAChE;AAEA,OAAK,cAAc,YAAY;AAChC;AAEM,mBAAA,oBAAA,QAAA;AAAA,qBAAgB,eAAC,SAAuB;AAC7C,MAAI,QAAQ,uBAAuBA,cAAA,MAAK,UAAA,EAAW,UAAU,OAAO;AACnE;EACD;AAEA,OAAK,YAAY,MAAM,aAAa,OAAO,EAAE,qBAAqB,CAAC;AACpE;AAEM,uBAAA,oBAAA,QAAA;AAAA,yBAAoB,eAAC,SAAuB;AACjD,QAAM,EAAE,QAAQ,aAAa,IAAIA,cAAA,MAAK,UAAA;AAEtC,QAAM,uBAA8C,CAAC;AAIrD,QAAM,mBAIA,CAAC;AAEP,SAAO,QAAQ,CAAC,UAAU;AACzB,QAAI,MAAM,SAAS,YAAY,OAAO,MAAM,UAAU,UAAU;AAE/D,uBAAiB,KAAK,EAAE,IAAI,oBAAoB,MAAM,KAAK,GAAG,MAAM,CAAC;AACrE;IACD;EACD,CAAC;AAED,eAAa,QAAQ,CAAC,gBAAgB;AAErC,QAAI,YAAY,SAAS,YAAY;AAIpC,YAAM,kBAAkB,YAAY,UAAU;QAC7C,CAAC,QAAQ,IAAI,SAAS,WAAW,CAAC,GAAG,OAAO,IAAI,KAAK,EAAE,OAAO,cAAc;MAC7E;AAEA,UAAI,iBAAiB;AACpB,6BAAqB,KAAK,WAAW;MACtC;IACD;AAIA,QAAI,YAAY,SAAS,cAAc;AACtC,kBAAY,QAAQ,QAAQ,CAAC,WAAW;AACvC,YAAI,OAAO,SAAS,SAAS;AAC5B,gBAAM,QAAQ,OAAO,OAAO,KAAK;AACjC,cAAI,OAAO,MAAM,UAAU,UAAU;AACpC,kBAAM,QAAQ,OAAO,KAAK,OAAI,IAAI,UAAU,MAAM,KAAK,CAAC;UACzD;QACD;MACD,CAAC;IACF;AAEA,QAAI,YAAY,SAAS,mBAAmB;AAC3C,UAAI,YAAY,QAAQ,SAAS,SAAS;AACzC,cAAM,QAAQ,OAAO,YAAY,QAAQ,KAAK;AAC9C,YAAI,OAAO,MAAM,UAAU,UAAU;AACpC,gBAAM,QAAQ,OAAO,KAAK,OAAI,QAAQ,UAAU,MAAM,KAAK,CAAC;QAC7D;MACD;IACD;EACD,CAAC;AAED,MAAI,qBAAqB,QAAQ;AAChC,UAAM,QAAQ;MACb,qBAAqB,IAAI,OAAO,aAAa;AAC5C,cAAM,CAAC,WAAW,YAAY,YAAY,IAAI,SAAS,OAAO,MAAM,IAAI;AAExE,cAAM,aAAa,MAAM,aAAa,OAAO,EAAE,0BAA0B;UACxE,SAAS,qBAAqB,SAAS;UACvC,QAAQ;UACR,UAAU;QACX,CAAC;AAKD,cAAM,eACL,WAAW,WAAW,SAAS,KAAK,YAAY,WAAW,WAAW,GAAG,EAAE,CAAE;AAE9E,cAAM,SAAS,eACZ,WAAW,WAAW,MAAM,GAAG,WAAW,WAAW,SAAS,CAAC,IAC/D,WAAW;AAEd,YAAI,OAAO,WAAW,SAAS,UAAU,QAAQ;AAChD,gBAAM,IAAI,MAAM,gCAAgC;QACjD;AAEA,eAAO,QAAQ,CAAC,OAAO,MAAM;AAC5B,gBAAM,MAAM,SAAS,UAAU,CAAC;AAChC,cAAI,IAAI,SAAS;AAAS;AAC1B,gBAAM,QAAQ,OAAO,IAAI,KAAK;AAE9B,cAAI,GAAG,MAAM,OAAO,cAAc;AAAG;AAErC,gBAAM,aAAa,MAAM;AAEzB,gBAAM,UAAU,yBAAyB,OAAO,UAAU;AAE1D,cAAI,SAAS;AACZ,kBAAM,QAAQ,OAAO,KAAK,YAAY,OAAO;AAC7C;UACD;AAEA,gBAAM,YAAY,iBAAiB,KAAK;AACxC,cAAI,aAAa,QAAS,OAAO,UAAU,YAAY,mBAAmB,OAAQ;AACjF,gBAAI,OAAO,eAAe,UAAU;AACnC,oBAAM,IAAI;gBACT,sDAAsD,KAAK;kBAC1D;kBACA;kBACA;gBACD,CAAA;cACD;YACD;AACA,6BAAiB,KAAK;cACrB,IAAI;cACJ;cACA,gBAAgB;YACjB,CAAC;AACD;UACD;AAEA,gBAAM,IAAI;YACT,yBAAyB,KAAK,UAAU,OAAO,MAAM,CAAC,CAAA,cAAe,KAAK;cACzE;cACA;cACA;YACD,CAAA;UACD;QACD,CAAC;MACF,CAAC;IACF;EACD;AAEA,MAAI,iBAAiB,QAAQ;AAC5B,UAAM,aAAa,CAAC,GAAG,IAAI,IAAI,iBAAiB,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE,CAAC,CAAC;AACpE,UAAM,eAAe,MAAM,YAAY,qBAAqB;AAC5D,UAAM,WACL,MAAM,QAAQ;MACb,aAAa;QAAI,CAACG,WACjB,aAAa,OAAO,EAAE,gBAAgB;UACrC,KAAKA;UACL,SAAS,EAAE,WAAW,KAAK;QAC5B,CAAC;MACF;IACD,GACC,KAAK;AAEP,QAAI,cAAc,IAAI;MACrB,WAAW,IAAI,CAAC,IAAI,UAAU;AAC7B,eAAO,CAAC,IAAI,QAAQ,KAAK,CAAC;MAC3B,CAAC;IACF;AAEA,UAAM,iBAAiB,MAAM,KAAK,WAAW,EAC3C,OAAO,CAAC,CAAC,GAAG,GAAG,MAAM,IAAI,KAAK,EAC9B,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,EAAE;AACrB,QAAI,eAAe,QAAQ;AAC1B,YAAM,IAAI,MAAM,4CAA4C,eAAe,KAAK,IAAI,CAAA,EAAG;IACxF;AAEA,qBAAiB,QAAQ,CAAC,EAAE,IAAI,OAAO,eAAe,MAAM;;AAC3D,YAAMC,UAAS,YAAY,IAAI,EAAE;AACjC,YAAM,SAAQ,KAAAA,QAAO,SAAP,mBAAa;AAC3B,YAAM,uBACL,SAAS,OAAO,UAAU,YAAY,YAAY,QAC/C,MAAM,OAAO,yBACb;AAEJ,UAAI,sBAAsB;AAIzB,cAAM,YACL,kBAAkB,QAClB,wBAAwB,cAAc,KAAK,QAC3C,iBAAiB,cAAc,KAAK;AACrC,cAAM,UACL,2BAA2B,MAAM,KAAK,KACtC,aACC,kBAAkB,QAAQ,wBAAwB,cAAc,KAAK;AAEvE,cAAM,QAAQ,OAAO,gBAAgB;UACpC,UAAU;UACV;UACA;QACD,CAAC;MACF,WAAW,kBAAkB,gBAAgB,cAAc,GAAG;AAC7D,cAAM,QAAQ,OAAO,aAAaA,QAAO,IAAK;MAC/C,OAAO;AACN,cAAM,QAAQ,OAAO,UAAUA,QAAO,IAAK;MAC5C;IACD,CAAC;EACF;AACD;AAMM,WAAA,oBAAA,QAAA;AAAA,aAAQ,eAAC,SAAuB;AACrC,MAAI,CAAC,QAAQ,uBAAuB,CAACJ,cAAA,MAAK,UAAA,EAAW,QAAQ;AAC5D,UAAM,IAAI,MAAM,4BAA4B;EAC7C;AAEA,MAAI,CAAC,QAAQ,kBAAkB,CAAC,QAAQ,UAAU,QAAQ,QAAQ;AACjE,YAAQ,iBAAiB,MAAM,QAAQ,OAAO,kBAAkB;EACjE;AAEA,QAAM,QAAQ,IAAI,CAAC,gBAAA,MAAK,kBAAA,kBAAA,EAAL,KAAA,MAAsB,OAAA,GAAU,gBAAA,MAAK,sBAAA,sBAAA,EAAL,KAAA,MAA0B,OAAA,CAAQ,CAAC;AAEtF,MAAI,CAAC,QAAQ,qBAAqB;AACjC,UAAM,gBAAA,MAAK,oBAAA,oBAAA,EAAL,KAAA,MAAwB,OAAA;AAE9B,QAAI,CAACA,cAAA,MAAK,UAAA,EAAW,UAAU,QAAQ;AACtC,YAAM,eAAe,MAAM,aAAa,OAAO,EAAE,uBAAuB;QACvE,kBAAkBA,cAAA,MAAK,UAAA,EAAW,MAAM;UACvC,cAAc,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,kBAAkB,OAAA;UAChD,WAAW;YACV,WAAW;cACV,QAAQ,OAAO,gBAAA,MAAK,YAAA,YAAA,EAAL,KAAA,MAAgB,YAAY,OAAA,CAAQ;cACnD,SAAS,CAAC;YACX;UACD;QACD,CAAC;MACF,CAAC;AACD,UAAI,aAAa,QAAQ,OAAO,WAAW,WAAW;AACrD,cAAM,IAAI;UACT,+DAA+D,aAAa,QAAQ,OAAO,KAAA;UAC3F,EAAE,OAAO,aAAa;QACvB;MACD;AAEA,YAAM,eAAe,oBAAoB,OAAO,KAAK,UAAU,UAAU,SAAS,EAAE;AAEpF,YAAM,kCACL,OAAO,aAAa,QAAQ,QAAQ,eAAe,IAAI;AAExD,YAAM,YACL,kCACA,OAAO,aAAa,QAAQ,QAAQ,WAAW,IAC/C,OAAO,aAAa,QAAQ,QAAQ,aAAa;AAGlD,WAAK;QACJ,YAAY,kCAAkC,YAAY;MAC3D;IACD;EACD;AAGA,kBAAA,MAAK,WAAA,WAAA,EAAL,KAAA,MAAe,OAAA;AAChB;",
  "names": ["i", "j", "string", "bs58", "base64String", "chunk", "bigint", "options", "name", "data", "writer", "reader", "name", "params", "typeName", "bcs", "SUI_ADDRESS_LENGTH", "SUI_ADDRESS_LENGTH", "mask", "create", "SUI_ADDRESS_LENGTH", "SuiObjectRef", "ObjectArg", "UpgradePolicy", "create", "TransactionExpiration", "SuiObjectRef", "create", "__privateAdd", "__privateSet", "__privateGet", "SuiObjectRef", "create", "chunk", "object"]
}
